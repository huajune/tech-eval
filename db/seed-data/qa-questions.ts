import { SeedQuestion } from "./types";

export const qaQuestions: SeedQuestion[] = [
  // 简单题（15题）
  {
    content: "在软件测试的 \"V 模型\" 中，与 \"详细设计\" 对应的测试阶段是？",
    type: "single",
    options: {
      A: "单元测试",
      B: "集成测试",
      C: "系统测试",
      D: "验收测试",
    },
    correctAnswer: ["A"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "详细设计对应单元测试，概要设计对应集成测试。",
  },
  {
    content: "登录功能，要求密码长度 6-12 位。以下哪个属于 \"无效等价类\"？",
    type: "single",
    options: {
      A: "密码长度 6 位",
      B: "密码长度 12 位",
      C: "密码长度 8 位",
      D: "密码长度 5 位",
    },
    correctAnswer: ["D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "5 位长度小于有效范围（6-12位），属于无效等价类。",
  },
  {
    content: "在 Linux 服务器上，查看当前目录下文件大小时，使用哪个命令最直观？",
    type: "single",
    options: {
      A: "ls -l",
      B: "ls -lh",
      C: "ps -ef",
      D: "cat file",
    },
    correctAnswer: ["B"],
    abilityDimension: "devops",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "-h 选项会以 K/M/G 等人类可读格式显示大小，最为直观。",
  },
  {
    content: "测试结束需要清理脏数据，删除表中所有数据但保留表结构的 SQL 是？",
    type: "single",
    options: {
      A: "DROP TABLE table_name;",
      B: "DELETE FROM table_name;",
      C: "REMOVE ALL FROM table_name;",
      D: "ALTER TABLE table_name DROP;",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "DELETE FROM 用于删除表中的数据但保留表结构，DROP TABLE 是删除整个表。",
  },
  {
    content: "使用 Fiddler/Charles 抓包时，想看请求的响应内容，应查看？",
    type: "single",
    options: {
      A: "Request Headers",
      B: "Response Body",
      C: "Cookies",
      D: "Protocol",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "响应内容（如 HTML、JSON）主要存放在响应体中。",
  },
  {
    content: "一条高质量的 Bug 单，最核心的要素是？",
    type: "single",
    options: {
      A: "标题够长",
      B: "必现 / 偶现、复现步骤、预期结果与实际结果",
      C: "必须附带视频",
      D: "必须指名道姓是谁写的 Bug",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "清晰的现象描述、可复现的步骤、明确的预期与实际结果差异是 Bug 单的核心，便于定位和修复问题。",
  },
  {
    content: "发现服务器磁盘满了，使用什么命令组合能最快找到是哪个文件占用了最大空间？",
    type: "single",
    options: {
      A: "ls -a",
      B: "find / -name \"*\"",
      C: "du -sh * | sort -rh | head",
      D: "top",
    },
    correctAnswer: ["C"],
    abilityDimension: "devops",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "du -sh * 查看当前目录下所有文件和目录的大小，sort -rh 逆序（从大到小）排序，head 取前几行。",
  },
  {
    content: "两个事务同时执行，事务 A 读到了事务 B 未提交的数据，这属于哪种隔离级别的问题？",
    type: "single",
    options: {
      A: "脏读 (Dirty Read)",
      B: "不可重复读",
      C: "幻读",
      D: "串行化",
    },
    correctAnswer: ["A"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "脏读特指读到了另一个事务未提交的数据，通常发生在隔离级别最低的 Read Uncommitted 级别。",
  },
  {
    content: "在使用 Selenium/Appium 进行 UI 自动化测试时，经常会遇到 StaleElementReferenceException (元素过期引用异常)。导致这个报错的常见原因有哪些？",
    type: "multiple",
    options: {
      A: "页面发生了刷新（Refresh）或跳转，导致原有的 DOM 节点销毁重建。",
      B: "页面使用了 Ajax 异步加载，在脚本查找元素时，DOM 树结构发生了变化（如节点被移除或更新）。",
      C: "元素的 ID 属性是非唯一的。",
      D: "网速太慢，导致元素还没加载出来（NoSuchElementException 的一种）。",
    },
    correctAnswer: ["A", "B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A/B 对：Stale 意味着\"陈旧的\"。脚本手里拿到的元素引用（Reference）对应的 DOM 节点在浏览器里已经不存在了（被刷新或JS重绘了），即使新加载出来的元素长得一模一样，ID也一样，引用ID也变了，必须重新 driver.findElement。C 错：ID 不唯一通常找错元素，不会报 Stale。D 错：没加载出来是 NoSuchElementException，不是 Stale。考察点：区分\"找不到元素\"和\"元素已过期\"，考察自动化脚本调试经验。",
  },
  {
    content: "压测某订单接口时，发现随着并发数增加，TPS（每秒事务数）上不去，CPU 占用率很低，但响应时间（RT）却变得非常长。造成这种情况的可能原因有哪些？",
    type: "multiple",
    options: {
      A: "数据库连接池满了，大量请求在排队等待获取连接。",
      B: "程序代码中存在死循环，消耗了大量计算资源。",
      C: "数据库中存在严重的锁等待（Lock Wait）或死锁。",
      D: "依赖的第三方支付接口响应超时，导致线程阻塞等待。",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A/C/D 对：这些都是典型的\"IO密集型\"或\"等待型\"瓶颈。线程都在 Wait 状态，所以 CPU 不忙（低），但请求处理不完（TPS低），排队久（RT高）。B 错：如果有死循环，CPU 占用率会直接飙升到 100%。考察点：性能瓶颈分析能力，区分 CPU 密集型和 IO 密集型问题。",
  },
  {
    content: "线上出现报错，你需要统计 error.log 日志中，\"NullPointerException\" 出现的次数，并按出现频率排序。以下哪些命令组合片段是相关的？",
    type: "multiple",
    options: {
      A: "grep \"NullPointerException\" error.log",
      B: "wc -l",
      C: "sort | uniq -c",
      D: "chmod +x",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "devops",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A：过滤出包含错误的行。B：统计行数（简单统计总数用）。C：排序并去重统计每种错误出现的次数（高级统计用）。完整命令可能是 grep \"Error\" log | sort | uniq -c | sort -nr。D 错：chmod 是修改文件权限的，与查看日志无关。考察点：Linux 管道组合命令的实际应用。",
  },
  {
    content: "测试秒杀活动时，发现大量请求直接打垮了数据库，但 Redis 缓存层似乎没起作用。这种情况（缓存穿透/击穿/雪崩）的可能原因有哪些？",
    type: "multiple",
    options: {
      A: "缓存雪崩：大量缓存 Key 在同一时间过期，导致请求全部涌向数据库。",
      B: "缓存穿透：黑客恶意请求大量数据库中不存在的 ID（如 id=-1），导致缓存不命中，直接查库。",
      C: "Redis 宕机：缓存服务挂了，没有配置高可用集群。",
      D: "数据一致性：数据库更新了，但缓存还没更新。",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A/B/C 对：这三者都会导致流量绕过缓存直接冲击数据库，造成数据库崩溃。D 错：数据不一致通常导致用户看到旧数据，而不是导致数据库崩溃（除非是为了保证强一致性加了重锁）。考察点：对高并发架构下缓存失效场景的理解。",
  },
  {
    content: "发现某条 SQL 查询语句执行非常慢（慢查询），为了分析原因，测试人员可以采取哪些手段？",
    type: "multiple",
    options: {
      A: "在 SQL 语句前加上 EXPLAIN 关键字，查看执行计划（是否命中索引）。",
      B: "检查 WHERE 条件字段的数据区分度（Selectivity），区分度太低（如性别）可能导致索引失效。",
      C: "只要给查询涉及的所有字段都加上索引，一定能解决问题。",
      D: "检查是否使用了 SELECT *，导致回表查询过多或传输数据量过大。",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A 对：最标准的排查手段。B 对：索引选择性差（如性别只有男女）会导致全表扫描。D 对：避免 Select * 是基础优化规范。C 错：索引不是越多越好，过多的索引会降低\"写入/更新\"速度，且不合理的联合索引可能根本用不上。考察点：数据库性能调优的基础意识。",
  },
  {
    content: "作为测试人员，你需要验证后台报表中的\"高价值用户列表\"。数据库中有一张订单表 orders，包含字段：user_id (用户ID) 和 amount (订单金额)。 你需要写一条 SQL，筛选出 平均订单金额超过 500 元 的所有用户 ID。下列 SQL 正确的是？",
    type: "single",
    options: {
      A: "SELECT user_id FROM orders WHERE AVG(amount) > 500 GROUP BY user_id;",
      B: "SELECT user_id FROM orders GROUP BY user_id HAVING AVG(amount) > 500;",
      C: "SELECT user_id FROM orders WHERE amount > 500 GROUP BY user_id;",
      D: "SELECT DISTINCT user_id FROM orders WHERE AVG(amount) > 500;",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "- A 错： WHERE 子句中不能直接使用聚合函数（如 AVG, SUM）。聚合后的过滤必须使用 HAVING。这是最经典的 SQL 面试坑。\n- B 对： 先 GROUP BY 用户，算出平均值，再用 HAVING 筛选平均值 > 500 的组。\n- C 错： 这条 SQL 的含义是\"筛选出单笔订单大于 500 的用户\"，而不是\"平均金额\"。\n- D 错： 语法错误，WHERE 中不能用 AVG。",
  },

  {
    content: "防止 XSS（跨站脚本攻击）最有效的手段是？",
    type: "single",
    options: {
      A: "使用 HTTPS",
      B: "对用户输入和输出进行严格的转义/过滤 (Escaping)",
      C: "使用 POST 代替 GET",
      D: "禁用 Cookie",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "XSS攻击的本质是恶意脚本在用户浏览器中执行。最根本的防御措施是在将不可信数据输出到HTML、CSS、JavaScript等上下文中时，根据上下文进行恰当的转义或过滤。其他选项不直接解决代码注入问题。",
  },
  {
    content: "页面加载性能指标中，FCP 指的是？",
    type: "single",
    options: {
      A: "First Contentful Paint (首次内容绘制)",
      B: "First CPU Processing",
      C: "Full Content Paint",
      D: "Fast Cache Page",
    },
    correctAnswer: ["A"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "FCP (First Contentful Paint) 是衡量用户感知加载速度的关键指标，指浏览器首次绘制来自DOM的任何内容（如文本、图片等）的时间点，标志着用户能看到\"东西\"了。",
  },

  // 中等题（1题）
  {
    content: "为了减少首屏加载时间（White Screen Time），前端可以采取哪些有效的技术手段？",
    type: "multiple",
    options: {
      A: "路由懒加载（Code Splitting）。",
      B: "开启 Gzip / Brotli 压缩。",
      C: "图片使用 WebP 格式或 CDN 加速。",
      D: "将所有 JS 代码合并成一个巨大的 bundle.js 以减少 HTTP 请求数。",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "D错：将所有代码打包成单个巨大文件会阻塞主线程解析，导致用户必须等待全部代码下载解析完毕后才能看到内容。现代最佳实践是利用HTTP/2多路复用优势，结合代码分割、按需加载来优化首屏。",
  },

  // 困难题（1题）
  {
    content: "你需要从数据库中导出所有 \"下过订单的用户\" 的姓名（即排除掉那些注册了但没买东西的人）。 现有两张表：用户表 users (字段：id, name) 和订单表 orders (字段：order_id, user_id, amount)。下列哪些 SQL 语句可以 正确 查出\"在 orders 表中有记录的用户姓名\"？",
    type: "multiple",
    options: {
      A: "SELECT DISTINCT u.name FROM users u INNER JOIN orders o ON u.id = o.user_id;",
      B: "SELECT u.name FROM users u LEFT JOIN orders o ON u.id = o.user_id WHERE o.order_id IS NULL;",
      C: "SELECT name FROM users WHERE id IN (SELECT user_id FROM orders);",
      D: "SELECT name FROM users u WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "database",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "- A 对 (INNER JOIN)： 内连接只保留两张表中都有关联的数据，正好筛选出\"下过单的用户\"。(加 DISTINCT 是为了去重，因为一个用户可能下多单)。\n- B 错 (逻辑相反)： LEFT JOIN 会保留所有用户，而 WHERE o.order_id IS NULL 是筛选出\"右边没数据的行\"。所以这句话查出来的是**\"没下过订单的用户\"**，与题目要求完全相反。这是考察对 LEFT JOIN 结果集过滤的经典考点。\n- C 对 (IN)： 筛选 ID 在订单表里的用户，逻辑正确。\n- D 对 (EXISTS)： 只要订单表存在关联记录就返回，逻辑正确且性能较好。",
  },
];
