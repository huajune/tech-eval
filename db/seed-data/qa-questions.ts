import { SeedQuestion } from "./types";

export const qaQuestions: SeedQuestion[] = [
  // 简单题（8题）
  {
    content: "防止 XSS（跨站脚本攻击）最有效的手段是？",
    type: "single",
    options: {
      A: "使用 HTTPS",
      B: "对用户输入和输出进行严格的转义/过滤 (Escaping)",
      C: "使用 POST 代替 GET",
      D: "禁用 Cookie",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "XSS攻击的本质是恶意脚本在用户浏览器中执行。最根本的防御措施是在将不可信数据输出到HTML、CSS、JavaScript等上下文中时，根据上下文进行恰当的转义或过滤。其他选项不直接解决代码注入问题。",
  },
  {
    content: "页面加载性能指标中，FCP 指的是？",
    type: "single",
    options: {
      A: "First Contentful Paint (首次内容绘制)",
      B: "First CPU Processing",
      C: "Full Content Paint",
      D: "Fast Cache Page",
    },
    correctAnswer: ["A"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "FCP (First Contentful Paint) 是衡量用户感知加载速度的关键指标，指浏览器首次绘制来自DOM的任何内容（如文本、图片等）的时间点，标志着用户能看到\"东西\"了。",
  },
  {
    content: "在软件测试的 “V 模型” 中，与 “详细设计” 对应的测试阶段是？",
    type: "single",
    options: {
      A: "单元测试",
      B: "集成测试",
      C: "系统测试",
      D: "验收测试",
    },
    correctAnswer: ["A"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend","backend","fullstack"],
    applicableLanguages: null,
    explanation: "详细设计对应单元测试，概要设计对应集成测试。",
  },
  {
    content: "登录功能，要求密码长度 6-12 位。以下哪个属于 “无效等价类”？",
    type: "single",
    options: {
      A: "密码长度 6 位",
      B: "密码长度 12 位",
      C: "密码长度 8 位",
      D: "密码长度 5 位",
    },
    correctAnswer: ["D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend","backend","fullstack"],
    applicableLanguages: null,
    explanation: "5 位长度小于有效范围（6-12位），属于无效等价类。",
  },
  {
    content: "使用 Fiddler/Charles 抓包时，想看请求的响应内容，应查看？",
    type: "single",
    options: {
      A: "Request Headers",
      B: "Response Body",
      C: "Cookies",
      D: "Protocol",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend","backend","fullstack"],
    applicableLanguages: null,
    explanation: "响应内容（如 HTML、JSON）主要存放在响应体中。",
  },
  {
    content: "一条高质量的 Bug 单，最核心的要素是？",
    type: "single",
    options: {
      A: "标题够长",
      B: "必现 / 偶现、复现步骤、预期结果与实际结果",
      C: "必须附带视频",
      D: "必须指名道姓是谁写的 Bug",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend","backend","fullstack"],
    applicableLanguages: null,
    explanation: "清晰的现象描述、可复现的步骤、明确的预期与实际结果差异是 Bug 单的核心，便于定位和修复问题。",
  },
  {
    content: "在使用 Selenium/Appium 进行 UI 自动化测试时，经常会遇到 StaleElementReferenceException (元素过期引用异常)。导致这个报错的常见原因有哪些？",
    type: "multiple",
    options: {
      A: "页面发生了刷新（Refresh）或跳转，导致原有的 DOM 节点销毁重建。",
      B: "页面使用了 Ajax 异步加载，在脚本查找元素时，DOM 树结构发生了变化（如节点被移除或更新）。",
      C: "元素的 ID 属性是非唯一的。",
      D: "网速太慢，导致元素还没加载出来（NoSuchElementException 的一种）。",
    },
    correctAnswer: ["A","B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend","backend","fullstack"],
    applicableLanguages: null,
    explanation: "A/B 对：Stale 意味着“陈旧的”。脚本手里拿到的元素引用（Reference）对应的 DOM 节点在浏览器里已经不存在了（被刷新或JS重绘了），即使新加载出来的元素长得一模一样，ID也一样，引用ID也变了，必须重新 driver.findElement。C 错：ID 不唯一通常找错元素，不会报 Stale。D 错：没加载出来是 NoSuchElementException，不是 Stale。考察点：区分“找不到元素”和“元素已过期”，考察自动化脚本调试经验。",
  },
  {
    content: "压测某订单接口时，发现随着并发数增加，TPS（每秒事务数）上不去，CPU 占用率很低，但响应时间（RT）却变得非常长。造成这种情况的可能原因有哪些？",
    type: "multiple",
    options: {
      A: "数据库连接池满了，大量请求在排队等待获取连接。",
      B: "程序代码中存在死循环，消耗了大量计算资源。",
      C: "数据库中存在严重的锁等待（Lock Wait）或死锁。",
      D: "依赖的第三方支付接口响应超时，导致线程阻塞等待。",
    },
    correctAnswer: ["A","C","D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend","backend","fullstack"],
    applicableLanguages: null,
    explanation: "A/C/D 对：这些都是典型的“IO密集型”或“等待型”瓶颈。线程都在 Wait 状态，所以 CPU 不忙（低），但请求处理不完（TPS低），排队久（RT高）。B 错：如果有死循环，CPU 占用率会直接飙升到 100%。考察点：性能瓶颈分析能力，区分 CPU 密集型和 IO 密集型问题。",
  },

  // 中等题（1题）
  {
    content: "为了减少首屏加载时间（White Screen Time），前端可以采取哪些有效的技术手段？",
    type: "multiple",
    options: {
      A: "路由懒加载（Code Splitting）。",
      B: "开启 Gzip / Brotli 压缩。",
      C: "图片使用 WebP 格式或 CDN 加速。",
      D: "将所有 JS 代码合并成一个巨大的 bundle.js 以减少 HTTP 请求数。",
    },
    correctAnswer: ["A","B","C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "D错：将所有代码打包成单个巨大文件会阻塞主线程解析，导致用户必须等待全部代码下载解析完毕后才能看到内容。现代最佳实践是利用HTTP/2多路复用优势，结合代码分割、按需加载来优化首屏。",
  }
];
