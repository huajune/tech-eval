import { SeedQuestion } from "./types";

export const qaQuestions: SeedQuestion[] = [
  // 简单题（15题）
  {
    content: "在软件测试的 \"V 模型\" 中，与 \"详细设计\" 对应的测试阶段是？",
    type: "single",
    options: {
      A: "单元测试",
      B: "集成测试",
      C: "系统测试",
      D: "验收测试",
    },
    correctAnswer: ["A"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "详细设计对应单元测试，概要设计对应集成测试。",
  },
  {
    content: "登录功能，要求密码长度 6-12 位。以下哪个属于 \"无效等价类\"？",
    type: "single",
    options: {
      A: "密码长度 6 位",
      B: "密码长度 12 位",
      C: "密码长度 8 位",
      D: "密码长度 5 位",
    },
    correctAnswer: ["D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "5 位长度小于有效范围（6-12位），属于无效等价类。",
  },
  {
    content: "在 Linux 服务器上，查看当前目录下文件大小时，使用哪个命令最直观？",
    type: "single",
    options: {
      A: "ls -l",
      B: "ls -lh",
      C: "ps -ef",
      D: "cat file",
    },
    correctAnswer: ["B"],
    abilityDimension: "devops",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "-h 选项会以 K/M/G 等人类可读格式显示大小，最为直观。",
  },
  {
    content: "测试结束需要清理脏数据，删除表中所有数据但保留表结构的 SQL 是？",
    type: "single",
    options: {
      A: "DROP TABLE table_name;",
      B: "DELETE FROM table_name;",
      C: "REMOVE ALL FROM table_name;",
      D: "ALTER TABLE table_name DROP;",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "DELETE FROM 用于删除表中的数据但保留表结构，DROP TABLE 是删除整个表。",
  },
  {
    content: "使用 Fiddler/Charles 抓包时，想看请求的响应内容，应查看？",
    type: "single",
    options: {
      A: "Request Headers",
      B: "Response Body",
      C: "Cookies",
      D: "Protocol",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "响应内容（如 HTML、JSON）主要存放在响应体中。",
  },
  {
    content: "一条高质量的 Bug 单，最核心的要素是？",
    type: "single",
    options: {
      A: "标题够长",
      B: "必现 / 偶现、复现步骤、预期结果与实际结果",
      C: "必须附带视频",
      D: "必须指名道姓是谁写的 Bug",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "清晰的现象描述、可复现的步骤、明确的预期与实际结果差异是 Bug 单的核心，便于定位和修复问题。",
  },
  {
    content: "发现服务器磁盘满了，使用什么命令组合能最快找到是哪个文件占用了最大空间？",
    type: "single",
    options: {
      A: "ls -a",
      B: "find / -name \"*\"",
      C: "du -sh * | sort -rh | head",
      D: "top",
    },
    correctAnswer: ["C"],
    abilityDimension: "devops",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "du -sh * 查看当前目录下所有文件和目录的大小，sort -rh 逆序（从大到小）排序，head 取前几行。",
  },
  {
    content: "两个事务同时执行，事务 A 读到了事务 B 未提交的数据，这属于哪种隔离级别的问题？",
    type: "single",
    options: {
      A: "脏读 (Dirty Read)",
      B: "不可重复读",
      C: "幻读",
      D: "串行化",
    },
    correctAnswer: ["A"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "脏读特指读到了另一个事务未提交的数据，通常发生在隔离级别最低的 Read Uncommitted 级别。",
  },
  {
    content: "在使用 Selenium/Appium 进行 UI 自动化测试时，经常会遇到 StaleElementReferenceException (元素过期引用异常)。导致这个报错的常见原因有哪些？",
    type: "multiple",
    options: {
      A: "页面发生了刷新（Refresh）或跳转，导致原有的 DOM 节点销毁重建。",
      B: "页面使用了 Ajax 异步加载，在脚本查找元素时，DOM 树结构发生了变化（如节点被移除或更新）。",
      C: "元素的 ID 属性是非唯一的。",
      D: "网速太慢，导致元素还没加载出来（NoSuchElementException 的一种）。",
    },
    correctAnswer: ["A", "B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A/B 对：Stale 意味着\"陈旧的\"。脚本手里拿到的元素引用（Reference）对应的 DOM 节点在浏览器里已经不存在了（被刷新或JS重绘了），即使新加载出来的元素长得一模一样，ID也一样，引用ID也变了，必须重新 driver.findElement。C 错：ID 不唯一通常找错元素，不会报 Stale。D 错：没加载出来是 NoSuchElementException，不是 Stale。考察点：区分\"找不到元素\"和\"元素已过期\"，考察自动化脚本调试经验。",
  },
  {
    content: "压测某订单接口时，发现随着并发数增加，TPS（每秒事务数）上不去，CPU 占用率很低，但响应时间（RT）却变得非常长。造成这种情况的可能原因有哪些？",
    type: "multiple",
    options: {
      A: "数据库连接池满了，大量请求在排队等待获取连接。",
      B: "程序代码中存在死循环，消耗了大量计算资源。",
      C: "数据库中存在严重的锁等待（Lock Wait）或死锁。",
      D: "依赖的第三方支付接口响应超时，导致线程阻塞等待。",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A/C/D 对：这些都是典型的\"IO密集型\"或\"等待型\"瓶颈。线程都在 Wait 状态，所以 CPU 不忙（低），但请求处理不完（TPS低），排队久（RT高）。B 错：如果有死循环，CPU 占用率会直接飙升到 100%。考察点：性能瓶颈分析能力，区分 CPU 密集型和 IO 密集型问题。",
  },
  {
    content: "线上出现报错，你需要统计 error.log 日志中，\"NullPointerException\" 出现的次数，并按出现频率排序。以下哪些命令组合片段是相关的？",
    type: "multiple",
    options: {
      A: "grep \"NullPointerException\" error.log",
      B: "wc -l",
      C: "sort | uniq -c",
      D: "chmod +x",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "devops",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A：过滤出包含错误的行。B：统计行数（简单统计总数用）。C：排序并去重统计每种错误出现的次数（高级统计用）。完整命令可能是 grep \"Error\" log | sort | uniq -c | sort -nr。D 错：chmod 是修改文件权限的，与查看日志无关。考察点：Linux 管道组合命令的实际应用。",
  },
  {
    content: "测试秒杀活动时，发现大量请求直接打垮了数据库，但 Redis 缓存层似乎没起作用。这种情况（缓存穿透/击穿/雪崩）的可能原因有哪些？",
    type: "multiple",
    options: {
      A: "缓存雪崩：大量缓存 Key 在同一时间过期，导致请求全部涌向数据库。",
      B: "缓存穿透：黑客恶意请求大量数据库中不存在的 ID（如 id=-1），导致缓存不命中，直接查库。",
      C: "Redis 宕机：缓存服务挂了，没有配置高可用集群。",
      D: "数据一致性：数据库更新了，但缓存还没更新。",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A/B/C 对：这三者都会导致流量绕过缓存直接冲击数据库，造成数据库崩溃。D 错：数据不一致通常导致用户看到旧数据，而不是导致数据库崩溃（除非是为了保证强一致性加了重锁）。考察点：对高并发架构下缓存失效场景的理解。",
  },
  {
    content: "发现某条 SQL 查询语句执行非常慢（慢查询），为了分析原因，测试人员可以采取哪些手段？",
    type: "multiple",
    options: {
      A: "在 SQL 语句前加上 EXPLAIN 关键字，查看执行计划（是否命中索引）。",
      B: "检查 WHERE 条件字段的数据区分度（Selectivity），区分度太低（如性别）可能导致索引失效。",
      C: "只要给查询涉及的所有字段都加上索引，一定能解决问题。",
      D: "检查是否使用了 SELECT *，导致回表查询过多或传输数据量过大。",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A 对：最标准的排查手段。B 对：索引选择性差（如性别只有男女）会导致全表扫描。D 对：避免 Select * 是基础优化规范。C 错：索引不是越多越好，过多的索引会降低\"写入/更新\"速度，且不合理的联合索引可能根本用不上。考察点：数据库性能调优的基础意识。",
  },
  {
    content: "作为测试人员，你需要验证后台报表中的\"高价值用户列表\"。数据库中有一张订单表 orders，包含字段：user_id (用户ID) 和 amount (订单金额)。 你需要写一条 SQL，筛选出 平均订单金额超过 500 元 的所有用户 ID。下列 SQL 正确的是？",
    type: "single",
    options: {
      A: "SELECT user_id FROM orders WHERE AVG(amount) > 500 GROUP BY user_id;",
      B: "SELECT user_id FROM orders GROUP BY user_id HAVING AVG(amount) > 500;",
      C: "SELECT user_id FROM orders WHERE amount > 500 GROUP BY user_id;",
      D: "SELECT DISTINCT user_id FROM orders WHERE AVG(amount) > 500;",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "- A 错： WHERE 子句中不能直接使用聚合函数（如 AVG, SUM）。聚合后的过滤必须使用 HAVING。这是最经典的 SQL 面试坑。\n- B 对： 先 GROUP BY 用户，算出平均值，再用 HAVING 筛选平均值 > 500 的组。\n- C 错： 这条 SQL 的含义是\"筛选出单笔订单大于 500 的用户\"，而不是\"平均金额\"。\n- D 错： 语法错误，WHERE 中不能用 AVG。",
  },

  {
    content: "防止 XSS（跨站脚本攻击）最有效的手段是？",
    type: "single",
    options: {
      A: "使用 HTTPS",
      B: "对用户输入和输出进行严格的转义/过滤 (Escaping)",
      C: "使用 POST 代替 GET",
      D: "禁用 Cookie",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "XSS攻击的本质是恶意脚本在用户浏览器中执行。最根本的防御措施是在将不可信数据输出到HTML、CSS、JavaScript等上下文中时，根据上下文进行恰当的转义或过滤。其他选项不直接解决代码注入问题。",
  },
  {
    content: "页面加载性能指标中，FCP 指的是？",
    type: "single",
    options: {
      A: "First Contentful Paint (首次内容绘制)",
      B: "First CPU Processing",
      C: "Full Content Paint",
      D: "Fast Cache Page",
    },
    correctAnswer: ["A"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "FCP (First Contentful Paint) 是衡量用户感知加载速度的关键指标，指浏览器首次绘制来自DOM的任何内容（如文本、图片等）的时间点，标志着用户能看到\"东西\"了。",
  },

  // 中等题（1题）
  {
    content: "为了减少首屏加载时间（White Screen Time），前端可以采取哪些有效的技术手段？",
    type: "multiple",
    options: {
      A: "路由懒加载（Code Splitting）。",
      B: "开启 Gzip / Brotli 压缩。",
      C: "图片使用 WebP 格式或 CDN 加速。",
      D: "将所有 JS 代码合并成一个巨大的 bundle.js 以减少 HTTP 请求数。",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "D错：将所有代码打包成单个巨大文件会阻塞主线程解析，导致用户必须等待全部代码下载解析完毕后才能看到内容。现代最佳实践是利用HTTP/2多路复用优势，结合代码分割、按需加载来优化首屏。",
  },

  // 新增题目 - frontend角色 (17题：12 easy + 5 medium)
  {
    content: "在测试前端页面时，发现某个按钮点击后没有反应。以下哪些排查方法是合理的？",
    type: "multiple",
    options: {
      A: "打开浏览器开发者工具，查看Console是否有错误",
      B: "检查Network面板，查看是否有请求发送",
      C: "检查Elements面板，查看按钮元素是否正确绑定事件",
      D: "不进行任何排查，直接报告Bug",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：Console查看错误、Network查看请求、Elements查看元素绑定都是前端问题排查的常用方法。D错：应该先排查再报告。",
  },
  {
    content: "在测试一个响应式网页时，以下哪些测试场景是必须的？",
    type: "single",
    options: {
      A: "只测试桌面端，移动端不重要",
      B: "测试不同屏幕尺寸（手机、平板、桌面），验证布局适配",
      C: "只测试一种浏览器",
      D: "不测试响应式，相信CSS会自动适配",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：响应式设计需要测试不同屏幕尺寸，确保在各种设备上正常显示。A错：移动端同样重要。C错：需要测试多种浏览器。D错：需要验证适配效果。",
  },
  {
    content: "在测试前端表单功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常提交：填写所有必填项，验证提交成功",
      B: "验证必填项：不填写必填项，验证提示信息",
      C: "验证格式：输入不符合格式的数据，验证错误提示",
      D: "不进行任何验证，直接提交",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：正常提交、必填项验证、格式验证都是表单测试的必要场景。D错：需要验证数据有效性。",
  },
  {
    content: "在测试前端页面的兼容性时，以下哪些浏览器是必须测试的？",
    type: "multiple",
    options: {
      A: "Chrome（最新版本）",
      B: "Firefox（最新版本）",
      C: "Safari（最新版本）",
      D: "只测试一种浏览器即可",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：Chrome、Firefox、Safari是主流浏览器，都需要测试。D错：不同浏览器可能有兼容性问题。",
  },
  {
    content: "在测试前端页面的性能时，以下哪些指标是重要的？",
    type: "multiple",
    options: {
      A: "首屏加载时间（FCP、LCP）",
      B: "页面交互响应时间（FID、CLS）",
      C: "JavaScript执行时间",
      D: "只关注页面是否加载，不关注性能",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：FCP、LCP、FID、CLS、JS执行时间都是重要的性能指标。D错：性能是用户体验的重要组成部分。",
  },
  {
    content: "在测试前端页面的安全性时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "XSS攻击测试：输入恶意脚本，验证是否被转义",
      B: "CSRF攻击测试：验证是否有CSRF token保护",
      C: "不进行安全测试，相信后端会处理",
      D: "验证敏感信息是否在前端代码中暴露",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：XSS、CSRF、敏感信息检查都是前端安全测试的重要内容。C错：前端也需要进行安全测试。",
  },
  {
    content: "在测试前端页面的可访问性（a11y）时，以下哪些检查是必要的？",
    type: "multiple",
    options: {
      A: "检查是否有合适的alt属性描述图片",
      B: "检查键盘导航是否正常工作",
      C: "检查颜色对比度是否满足WCAG标准",
      D: "不进行可访问性测试，只关注功能",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：alt属性、键盘导航、颜色对比度都是可访问性的重要检查项。D错：可访问性是重要的用户体验指标。",
  },
  {
    content: "在测试前端页面的加载性能时，以下哪些工具是常用的？",
    type: "multiple",
    options: {
      A: "Chrome DevTools的Performance面板",
      B: "Lighthouse进行性能评分",
      C: "Network面板分析资源加载",
      D: "不使用任何工具，凭感觉判断",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：Performance面板、Lighthouse、Network面板都是性能测试的常用工具。D错：需要使用工具进行客观评估。",
  },
  {
    content: "在测试前端页面的交互功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常交互：点击按钮、输入文本、选择选项等",
      B: "异常交互：快速连续点击、输入超长文本等",
      C: "边界交互：输入边界值、测试极限情况",
      D: "只测试正常交互，不测试异常情况",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：正常交互、异常交互、边界交互都是交互测试的必要场景。D错：异常情况也需要测试。",
  },
  {
    content: "在测试前端页面的数据展示时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常数据：验证数据正确显示",
      B: "空数据：验证空状态提示",
      C: "异常数据：验证错误提示",
      D: "只测试正常数据，不测试异常情况",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：正常数据、空数据、异常数据都是数据展示测试的必要场景。D错：异常情况也需要测试。",
  },
  {
    content: "在测试前端页面的路由跳转时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常跳转：点击链接，验证页面跳转正确",
      B: "浏览器前进后退：验证历史记录功能",
      C: "直接访问URL：验证路由配置正确",
      D: "不测试路由，只测试页面内容",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：正常跳转、前进后退、直接访问都是路由测试的必要场景。D错：路由功能也需要测试。",
  },
  {
    content: "在测试前端页面的状态管理时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "状态更新：验证状态变化后UI正确更新",
      B: "状态持久化：验证刷新页面后状态保持",
      C: "状态同步：验证多个组件状态同步",
      D: "不测试状态，只测试UI显示",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：状态更新、持久化、同步都是状态管理测试的必要场景。D错：状态管理也需要测试。",
  },
  {
    content: "在测试前端页面的错误处理时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "网络错误：断网时验证错误提示",
      B: "API错误：返回错误状态码时验证错误处理",
      C: "超时错误：请求超时时验证错误提示",
      D: "不测试错误，只测试正常情况",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：网络错误、API错误、超时错误都是错误处理测试的必要场景。D错：错误处理也需要测试。",
  },
  {
    content: "在测试前端页面的缓存功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "缓存命中：验证缓存数据正确使用",
      B: "缓存失效：验证缓存过期后重新请求",
      C: "缓存更新：验证数据更新后缓存刷新",
      D: "不测试缓存，每次都重新请求",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：缓存命中、失效、更新都是缓存测试的必要场景。D错：缓存功能也需要测试。",
  },
  {
    content: "在测试前端页面的实时更新功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "WebSocket连接：验证实时数据推送",
      B: "连接断开：验证断线重连机制",
      C: "数据同步：验证多端数据同步",
      D: "不测试实时功能，只测试静态数据",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：WebSocket连接、断线重连、数据同步都是实时功能测试的必要场景。D错：实时功能也需要测试。",
  },
  {
    content: "在测试前端页面的国际化功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "语言切换：验证切换语言后内容正确显示",
      B: "文本长度：验证不同语言文本长度适配",
      C: "日期格式：验证不同地区的日期格式",
      D: "只测试一种语言，不测试多语言",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：语言切换、文本长度、日期格式都是国际化测试的必要场景。D错：多语言功能也需要测试。",
  },
  {
    content: "在测试前端页面的离线功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "离线访问：断网后验证页面是否可用",
      B: "数据同步：上线后验证离线数据同步",
      C: "缓存策略：验证Service Worker缓存是否生效",
      D: "不测试离线功能，只测试在线功能",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：离线访问、数据同步、缓存策略都是离线功能测试的必要场景。D错：离线功能也需要测试。",
  },
  {
    content: "你在测试一个复杂的前端应用，需要设计一个完整的测试方案。请说明如何设计测试用例，包括功能测试、性能测试、兼容性测试等。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 5,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "本题考察前端测试方案设计能力。",
    referenceAnswer: "功能测试方案：1）核心功能：测试主要业务流程，如登录、下单、支付等；2）边界测试：测试输入边界值、极限情况；3）异常测试：测试网络错误、API错误、超时等异常场景；4）交互测试：测试按钮点击、表单提交、页面跳转等交互功能。性能测试方案：1）加载性能：使用Lighthouse测试FCP、LCP、FID、CLS等指标；2）运行时性能：使用Performance面板分析JS执行时间、内存使用；3）资源优化：检查图片、CSS、JS文件大小和加载时间；4）网络优化：检查请求数量、CDN使用、缓存策略。兼容性测试方案：1）浏览器兼容：测试Chrome、Firefox、Safari、Edge等主流浏览器；2）设备兼容：测试不同屏幕尺寸（手机、平板、桌面）；3）操作系统兼容：测试Windows、macOS、iOS、Android；4）版本兼容：测试浏览器不同版本。可访问性测试：1）键盘导航：验证所有功能可以通过键盘操作；2）屏幕阅读器：验证屏幕阅读器可以正确读取内容；3）颜色对比度：验证文本和背景颜色对比度满足WCAG标准；4）ARIA标签：验证关键元素有合适的ARIA标签。安全测试：1）XSS测试：输入恶意脚本，验证是否被转义；2）CSRF测试：验证是否有CSRF token保护；3）敏感信息：检查前端代码是否暴露敏感信息。评分标准：测试方案完整（功能、性能、兼容性）（2分），考虑可访问性和安全（1分），有具体测试工具和方法（1分），方案实用可落地（1分）。",
  },


  // 困难题（1题）
  {
    content: "你需要从数据库中导出所有 \"下过订单的用户\" 的姓名（即排除掉那些注册了但没买东西的人）。 现有两张表：用户表 users (字段：id, name) 和订单表 orders (字段：order_id, user_id, amount)。下列哪些 SQL 语句可以 正确 查出\"在 orders 表中有记录的用户姓名\"？",
    type: "multiple",
    options: {
      A: "SELECT DISTINCT u.name FROM users u INNER JOIN orders o ON u.id = o.user_id;",
      B: "SELECT u.name FROM users u LEFT JOIN orders o ON u.id = o.user_id WHERE o.order_id IS NULL;",
      C: "SELECT name FROM users WHERE id IN (SELECT user_id FROM orders);",
      D: "SELECT name FROM users u WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "database",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "- A 对 (INNER JOIN)： 内连接只保留两张表中都有关联的数据，正好筛选出\"下过单的用户\"。(加 DISTINCT 是为了去重，因为一个用户可能下多单)。\n- B 错 (逻辑相反)： LEFT JOIN 会保留所有用户，而 WHERE o.order_id IS NULL 是筛选出\"右边没数据的行\"。所以这句话查出来的是**\"没下过订单的用户\"**，与题目要求完全相反。这是考察对 LEFT JOIN 结果集过滤的经典考点。\n- C 对 (IN)： 筛选 ID 在订单表里的用户，逻辑正确。\n- D 对 (EXISTS)： 只要订单表存在关联记录就返回，逻辑正确且性能较好。",
  },

  // 新增题目 - easy (6题，含1题简答)
  {
    content: "在测试登录功能时，以下哪个测试用例属于边界值测试？",
    type: "single",
    options: {
      A: "输入正确的用户名和密码，验证登录成功",
      B: "输入用户名长度为5位（最小长度），验证登录",
      C: "输入错误的用户名，验证登录失败",
      D: "不输入任何内容，直接点击登录按钮",
    },
    correctAnswer: ["B"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "B对：边界值测试是测试输入参数的边界条件，如最小长度、最大长度等。A错：这是正常场景测试。C错：这是异常场景测试。D错：这是空值测试。",
  },
  {
    content: "在使用 Postman 进行 API 测试时，以下哪种方式可以测试接口的并发性能？",
    type: "single",
    options: {
      A: "使用 Collection Runner 运行测试集合",
      B: "使用 Newman 命令行工具运行",
      C: "使用 Postman 的 Runner 功能设置迭代次数和延迟",
      D: "Postman 不支持并发测试，需要使用 JMeter",
    },
    correctAnswer: ["D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "D对：Postman主要用于功能测试，并发性能测试应该使用JMeter、LoadRunner等专业工具。A/B/C错：这些方式都是串行执行，无法真正模拟并发场景。",
  },
  {
    content: "在编写自动化测试脚本时，以下哪种等待方式最可靠？",
    type: "single",
    options: {
      A: "使用固定时间等待，如 sleep(5)",
      B: "使用隐式等待（implicit wait）",
      C: "使用显式等待（explicit wait），等待特定元素出现",
      D: "不使用任何等待，直接操作元素",
    },
    correctAnswer: ["C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "C对：显式等待可以等待特定条件满足后再执行，既保证稳定性又不会浪费过多时间。A错：固定等待时间不可靠，可能等待时间不够或过长。B错：隐式等待是全局设置，可能影响所有操作。D错：元素可能还没加载完成就操作，导致测试失败。",
  },
  {
    content: "在测试一个电商系统的下单功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常下单流程：选择商品、填写地址、支付成功",
      B: "库存不足时的下单场景",
      C: "支付失败时的订单状态",
      D: "用户取消订单的场景",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A对：正常流程是基础测试。B对：异常场景测试可以验证系统容错能力。C对：支付失败是常见异常场景。D对：取消订单是正常业务场景，需要测试。",
  },
  {
    content: "在分析测试覆盖率时，以下哪些指标是重要的？",
    type: "multiple",
    options: {
      A: "代码覆盖率（Code Coverage）",
      B: "功能覆盖率（Function Coverage）",
      C: "分支覆盖率（Branch Coverage）",
      D: "只需要测试正常流程，异常流程不重要",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A/B/C对：这些都是测试覆盖率的重要指标，可以从不同维度评估测试完整性。D错：异常流程测试同样重要，可以验证系统容错能力。",
  },
  {
    content: "你需要测试一个登录功能，包括正常场景和异常场景。请设计测试用例，说明测试要点。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 5,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "本题考察测试用例设计能力。",
    referenceAnswer: "正常场景测试用例：1）正确用户名和密码登录成功；2）记住密码功能，下次自动填充；3）登录后跳转到正确页面；4）登录状态保持，刷新页面不退出。异常场景测试用例：1）用户名或密码错误，提示错误信息；2）用户名为空或密码为空，提示必填项；3）密码长度不符合要求（如少于6位），提示格式错误；4）连续多次输入错误密码，触发账户锁定机制；5）验证码错误，提示重新输入；6）网络异常时，提示网络错误；7）已登录状态下再次登录，提示已登录或强制退出。边界值测试：1）用户名最大长度、最小长度；2）密码最大长度、最小长度；3）特殊字符输入（SQL注入、XSS攻击测试）。测试要点：1）功能正确性：验证登录成功后的状态和跳转；2）安全性：验证密码加密、防暴力破解、防SQL注入；3）用户体验：错误提示清晰、加载状态显示；4）兼容性：不同浏览器、不同设备测试；5）性能：登录响应时间、并发登录测试。评分标准：正常场景完整（1分），异常场景覆盖全面（2分），考虑安全性和边界值（1分），测试要点清晰（1分）。",
  },

  // 新增题目 - medium (4题，含1题简答)
  {
    content: "在设计接口性能测试方案时，需要考虑哪些关键指标？",
    type: "multiple",
    options: {
      A: "响应时间（Response Time），包括平均响应时间、P95、P99",
      B: "吞吐量（Throughput），即TPS或QPS",
      C: "错误率（Error Rate），统计请求失败的比例",
      D: "资源使用率，如CPU、内存、网络带宽",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A对：响应时间是用户体验的关键指标。B对：吞吐量反映系统处理能力。C对：错误率反映系统稳定性。D对：资源使用率可以定位性能瓶颈。",
  },
  {
    content: "在搭建自动化测试框架时，以下哪些设计原则是重要的？",
    type: "multiple",
    options: {
      A: "使用Page Object模式，将页面元素和操作封装",
      B: "测试数据和测试代码分离，便于维护",
      C: "使用数据驱动，支持多组测试数据",
      D: "所有测试用例都写在一个文件中，方便查看",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A对：Page Object模式可以提高代码可维护性。B对：数据分离便于维护和扩展。C对：数据驱动可以提高测试覆盖率。D错：应该按模块或功能拆分，便于维护。",
  },
  {
    content: "在执行压力测试时，以下哪些场景可能导致测试结果不准确？",
    type: "multiple",
    options: {
      A: "测试环境配置与生产环境差异较大",
      B: "测试数据量不足，无法模拟真实场景",
      C: "网络环境不稳定，存在延迟和丢包",
      D: "使用真实的生产数据进行测试",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A对：环境差异会导致测试结果无法反映生产环境真实情况。B对：数据量不足无法模拟真实负载。C对：网络不稳定会影响测试结果。D错：使用生产数据测试是合理的，但要注意数据脱敏。",
  },
  {
    content: "你需要为一个订单接口设计性能测试方案，包括测试指标、测试场景和预期结果。请设计完整的测试方案。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 5,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "本题考察性能测试方案设计能力。",
    referenceAnswer: "测试目标：验证订单接口在正常负载和峰值负载下的性能表现，确保系统可以支撑预期业务量。测试指标：1）响应时间：平均响应时间<200ms，P95<500ms，P99<1000ms；2）吞吐量：正常负载下TPS>1000，峰值负载下TPS>2000；3）错误率：<0.1%；4）资源使用率：CPU<70%，内存<80%，数据库连接数<80%。测试场景设计：1）基准测试：单用户连续请求100次，建立性能基线；2）负载测试：逐步增加并发用户数（10、50、100、200），观察系统表现；3）压力测试：持续增加负载直到系统达到性能拐点，观察系统极限；4）稳定性测试：在正常负载下持续运行2小时，观察是否有内存泄漏、性能下降；5）峰值测试：模拟秒杀场景，瞬间1000并发，验证系统抗压能力。测试数据准备：1）准备10万条订单数据；2）准备1000个测试用户账号；3）模拟不同订单状态（待支付、已支付、已发货等）。测试工具：使用JMeter或LoadRunner，配置线程组、HTTP请求、断言、监听器。预期结果：1）所有测试场景下响应时间符合要求；2）吞吐量达到预期；3）错误率低于阈值；4）系统资源使用正常，无内存泄漏；5）数据库查询性能正常，无慢查询。评分标准：测试指标完整（2分），测试场景设计合理（1分），有具体测试工具和配置（1分），预期结果明确（1分）。",
  },

  // 新增题目 - hard (2题，含1题简答)
  {
    content: "在设计秒杀功能的测试方案时，需要考虑哪些测试维度？",
    type: "multiple",
    options: {
      A: "功能测试：验证秒杀流程、库存扣减、订单创建等",
      B: "性能测试：高并发场景下的系统表现，如1万QPS",
      C: "压力测试：持续高负载下的系统稳定性",
      D: "安全测试：防刷、防重复提交、防库存超卖",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "qa_testing",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "A对：功能测试是基础，确保业务逻辑正确。B对：秒杀场景的核心是高并发，必须进行性能测试。C对：压力测试可以验证系统在极限情况下的表现。D对：秒杀场景容易受到攻击，安全测试必不可少。",
  },
  {
    content: "你需要设计一个秒杀功能的完整测试方案，包括功能测试、性能测试、压力测试等。请设计详细的测试方案。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "qa_testing",
    difficulty: "hard",
    weight: 5,
    applicableRoles: ["tester"],
    applicableLanguages: null,
    explanation: "本题考察复杂场景的测试方案设计能力。",
    referenceAnswer: "功能测试方案：1）正常流程：用户登录→进入秒杀页面→点击秒杀按钮→库存扣减→订单创建→支付；2）异常流程：库存为0时提示已抢完、重复点击防重复提交、未登录用户跳转登录、支付超时订单自动取消；3）边界测试：库存为1时的并发抢购、秒杀开始前和结束后的访问控制、用户限购数量验证。性能测试方案：1）测试目标：支持1万QPS，响应时间P99<500ms；2）测试场景：模拟1万个用户同时点击秒杀按钮，持续30秒；3）关键指标：接口响应时间、TPS、错误率、数据库连接数、Redis连接数；4）性能瓶颈分析：使用APM工具定位慢接口，分析数据库慢查询，检查Redis性能。压力测试方案：1）逐步加压：从1000并发开始，每30秒增加1000并发，直到系统达到极限；2）持续压测：在正常负载下持续运行1小时，观察系统稳定性；3）峰值测试：瞬间1万并发，验证系统抗压能力；4）恢复测试：压力释放后，验证系统能否快速恢复。安全测试方案：1）防刷测试：使用工具模拟大量请求，验证限流机制；2）防重复提交：快速连续点击，验证防重复提交机制；3）防库存超卖：并发抢购，验证库存扣减的原子性；4）SQL注入和XSS测试：输入恶意脚本，验证系统安全性。测试数据准备：1）准备100个秒杀商品，每个商品库存100件；2）准备1万个测试用户账号；3）准备测试环境，配置与生产环境一致（至少是生产环境的1/4规模）。测试工具：JMeter（性能测试）+ Postman（功能测试）+ 浏览器开发者工具（前端测试）。预期结果：1）功能测试：所有测试用例通过；2）性能测试：支持1万QPS，响应时间符合要求；3）压力测试：系统稳定，无内存泄漏，无数据不一致；4）安全测试：通过所有安全测试用例。评分标准：测试维度完整（功能、性能、压力、安全）（2分），测试场景设计详细（1分），有具体测试工具和指标（1分），方案可落地执行（1分）。",
  },

  // 新增题目 - backend角色 qa_testing (20题：12 easy + 6 medium + 2 hard)
  {
    content: "在测试后端接口时，你发现某个接口返回了500错误。以下哪些排查方法是合理的？",
    type: "multiple",
    options: {
      A: "查看应用日志，定位错误堆栈",
      B: "检查数据库连接是否正常",
      C: "验证请求参数是否正确",
      D: "不进行排查，直接重启服务",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：查看日志、检查数据库、验证参数都是接口错误排查的常用方法。D错：重启服务不能解决根本问题。",
  },
  {
    content: "在测试后端接口的性能时，以下哪些指标是重要的？",
    type: "multiple",
    options: {
      A: "接口响应时间（平均、P95、P99）",
      B: "接口吞吐量（TPS、QPS）",
      C: "接口错误率",
      D: "只关注接口是否可用，不关注性能",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：响应时间、吞吐量、错误率都是接口性能测试的重要指标。D错：性能是接口质量的重要组成部分。",
  },
  {
    content: "在测试后端接口的安全性时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "SQL注入测试：输入恶意SQL语句",
      B: "XSS攻击测试：输入恶意脚本",
      C: "不进行安全测试，相信代码是安全的",
      D: "验证接口是否有权限控制",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/D对：SQL注入、XSS、权限控制都是接口安全测试的重要内容。C错：安全测试是必要的。",
  },
  {
    content: "在测试后端接口的参数验证时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常参数：验证接口正常返回",
      B: "异常参数：输入不符合要求的数据，验证错误提示",
      C: "边界参数：输入边界值，验证边界处理",
      D: "只测试正常参数，不测试异常情况",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：正常参数、异常参数、边界参数都是参数验证测试的必要场景。D错：异常情况也需要测试。",
  },
  {
    content: "在测试后端接口的并发性能时，以下哪些工具是常用的？",
    type: "multiple",
    options: {
      A: "JMeter - 进行压力测试和性能测试",
      B: "Postman - 进行功能测试",
      C: "Apache Bench (ab) - 进行简单的压力测试",
      D: "不使用任何工具，凭感觉判断",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：JMeter、Postman、ab都是接口测试的常用工具。D错：需要使用工具进行客观评估。",
  },
  {
    content: "在测试后端接口的数据一致性时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "并发更新：多个请求同时更新同一数据",
      B: "事务回滚：验证事务失败时数据回滚",
      C: "数据校验：验证数据更新后的一致性",
      D: "不测试数据一致性，只测试功能",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：并发更新、事务回滚、数据校验都是数据一致性测试的必要场景。D错：数据一致性也需要测试。",
  },
  {
    content: "在测试后端接口的异常处理时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "网络异常：模拟网络中断，验证错误处理",
      B: "数据库异常：模拟数据库连接失败，验证错误处理",
      C: "业务异常：输入不符合业务规则的数据，验证错误提示",
      D: "不测试异常，只测试正常情况",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：网络异常、数据库异常、业务异常都是异常处理测试的必要场景。D错：异常处理也需要测试。",
  },
  {
    content: "在测试后端接口的缓存功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "缓存命中：验证缓存数据正确使用",
      B: "缓存失效：验证缓存过期后重新请求",
      C: "缓存更新：验证数据更新后缓存刷新",
      D: "不测试缓存，每次都重新请求",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：缓存命中、失效、更新都是缓存测试的必要场景。D错：缓存功能也需要测试。",
  },
  {
    content: "在测试后端接口的限流功能时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常请求：验证正常请求可以正常处理",
      B: "超限请求：验证超过限流阈值时的处理",
      C: "限流恢复：验证限流解除后恢复正常",
      D: "不测试限流，相信系统不会超载",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：正常请求、超限请求、限流恢复都是限流测试的必要场景。D错：限流功能也需要测试。",
  },
  {
    content: "在测试后端接口的幂等性时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "重复请求：验证相同请求多次执行的结果一致",
      B: "并发请求：验证并发请求不会导致重复处理",
      C: "请求重试：验证请求失败后重试不会重复处理",
      D: "不测试幂等性，相信接口是幂等的",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：重复请求、并发请求、请求重试都是幂等性测试的必要场景。D错：幂等性也需要测试。",
  },
  {
    content: "在测试后端接口的版本兼容性时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "新版本接口：验证新版本接口功能正常",
      B: "旧版本接口：验证旧版本接口仍然可用",
      C: "版本切换：验证版本切换不影响功能",
      D: "只测试最新版本，不测试旧版本",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：新版本、旧版本、版本切换都是版本兼容性测试的必要场景。D错：需要保证向后兼容。",
  },
  {
    content: "在测试后端接口的日志记录时，以下哪些检查是必要的？",
    type: "multiple",
    options: {
      A: "验证关键操作都有日志记录",
      B: "验证日志包含必要的上下文信息",
      C: "验证敏感信息不会记录到日志",
      D: "不检查日志，只关注功能",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：日志记录、上下文信息、敏感信息保护都是日志检查的重要内容。D错：日志是问题排查的重要依据。",
  },
  {
    content: "在测试后端接口的监控告警时，以下哪些指标需要设置告警？",
    type: "multiple",
    options: {
      A: "接口错误率超过阈值（如>1%）",
      B: "接口响应时间超过阈值（如P99>1s）",
      C: "接口QPS突降超过阈值（如>50%）",
      D: "不设置告警，相信系统总是正常",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：错误率、响应时间、QPS突降都是需要监控和告警的关键指标。D错：告警是必要的。",
  },
  {
    content: "在测试后端接口的分布式场景时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "服务降级：验证服务不可用时的降级处理",
      B: "服务熔断：验证服务异常时的熔断机制",
      C: "数据一致性：验证分布式环境下的数据一致性",
      D: "不测试分布式场景，只测试单机场景",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：服务降级、熔断、数据一致性都是分布式场景测试的重要内容。D错：分布式场景也需要测试。",
  },
  {
    content: "在测试后端接口的幂等性实现时，以下哪些方案是可行的？",
    type: "multiple",
    options: {
      A: "使用唯一请求ID（如UUID）标识请求",
      B: "使用数据库唯一约束防止重复",
      C: "使用Redis分布式锁防止重复处理",
      D: "不实现幂等性，相信不会重复请求",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：唯一请求ID、数据库唯一约束、Redis分布式锁都是实现幂等性的常见方案。D错：幂等性是重要的接口特性。",
  },
  {
    content: "在测试后端接口的缓存策略时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "缓存穿透：请求不存在的数据，验证防护机制",
      B: "缓存击穿：热点数据过期，验证防护机制",
      C: "缓存雪崩：大量缓存同时过期，验证防护机制",
      D: "不测试缓存问题，相信缓存总是可用",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：缓存穿透、击穿、雪崩都是缓存测试的重要场景。D错：缓存问题也需要测试。",
  },
  {
    content: "在测试后端接口的分布式事务时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "正常提交：验证分布式事务正常提交",
      B: "异常回滚：验证分布式事务异常回滚",
      C: "部分成功：验证部分服务成功部分失败的处理",
      D: "不测试分布式事务，只测试本地事务",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：正常提交、异常回滚、部分成功都是分布式事务测试的必要场景。D错：分布式事务也需要测试。",
  },
  {
    content: "在测试后端接口的限流降级时，以下哪些测试场景是必须的？",
    type: "multiple",
    options: {
      A: "限流触发：验证限流触发时的处理",
      B: "降级触发：验证降级触发时的处理",
      C: "恢复机制：验证限流降级解除后的恢复",
      D: "不测试限流降级，相信系统不会超载",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：限流触发、降级触发、恢复机制都是限流降级测试的必要场景。D错：限流降级也需要测试。",
  },
  {
    content: "你在测试一个高并发的订单接口，需要设计一个完整的测试方案。请说明如何设计测试用例，包括功能测试、性能测试、压力测试等。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "qa_testing",
    difficulty: "medium",
    weight: 5,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "本题考察后端接口测试方案设计能力。",
    referenceAnswer: "功能测试方案：1）正常流程：创建订单→库存扣减→订单支付→订单完成；2）异常流程：库存不足、支付失败、订单取消等；3）边界测试：库存为1时的并发下单、订单金额边界值等；4）数据校验：验证订单数据完整性、一致性。性能测试方案：1）测试指标：响应时间P99<500ms、TPS>1000、错误率<0.1%；2）测试场景：基准测试、负载测试、压力测试、稳定性测试；3）性能分析：使用APM工具分析慢接口、数据库慢查询、JVM性能；4）瓶颈定位：分析CPU、内存、数据库、网络等资源使用情况。压力测试方案：1）逐步加压：从100并发开始，逐步增加到1000并发；2）持续压测：在正常负载下持续运行1小时；3）峰值测试：瞬间1000并发，验证系统抗压能力；4）恢复测试：压力释放后验证系统恢复。安全测试：1）SQL注入测试；2）XSS攻击测试；3）权限验证测试；4）敏感信息泄露测试。评分标准：测试方案完整（功能、性能、压力）（2分），考虑安全测试（1分），有具体测试工具和指标（1分），方案实用可落地（1分）。",
  },
  {
    content: "你在测试一个需要保证数据一致性的分布式系统，涉及多个服务和数据库。请设计一个测试方案，验证分布式事务的数据一致性。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "qa_testing",
    difficulty: "hard",
    weight: 5,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "本题考察分布式系统数据一致性测试能力。",
    referenceAnswer: "测试场景设计：1）正常提交：所有服务都成功，验证数据一致性；2）部分失败：部分服务成功部分失败，验证事务回滚；3）网络异常：模拟网络中断，验证事务处理；4）服务超时：模拟服务响应超时，验证超时处理；5）并发冲突：多个事务同时操作同一数据，验证冲突处理。测试方法：1）使用分布式事务框架（如Seata）的测试工具；2）模拟各种异常场景，验证事务处理；3）使用数据库事务日志验证数据一致性；4）实现数据校验脚本，验证最终一致性。测试数据准备：1）准备测试数据，包括正常数据和异常数据；2）实现数据快照，便于恢复和对比；3）实现数据校验规则，验证数据一致性。测试工具：1）使用JMeter模拟并发请求；2）使用APM工具监控事务执行；3）使用数据库工具查看事务日志；4）实现自动化测试脚本。预期结果：1）正常场景下数据一致；2）异常场景下事务正确回滚；3）并发场景下数据不冲突；4）最终一致性得到保证。评分标准：测试场景完整（2分），测试方法合理（1分），考虑并发和异常（1分），方案实用可落地（1分）。",
  },
];
