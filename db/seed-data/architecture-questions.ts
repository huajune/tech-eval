import { SeedQuestion } from "./types";

export const architectureQuestions: SeedQuestion[] = [
  // 简单题（10题）
  {
    content: "HTTP 协议中，状态码 304 Not Modified 表示？",
    type: "single",
    options: {
      A: "资源永久移动",
      B: "服务器内部错误",
      C: "资源未修改，客户端可直接使用本地缓存",
      D: "没有权限访问",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "304状态码属于HTTP协商缓存的一部分。当客户端发送包含缓存验证信息的请求后，如果服务器判断资源自上次请求以来未发生修改，就会返回304，指示客户端使用本地缓存的版本。",
  },
  {
    content: "下列哪种情况不会触发 JVM 的类加载（Class Loading）？",
    type: "single",
    options: {
      A: "new 一个对象",
      B: "访问类的静态变量（static int x = 1）",
      C: "通过数组定义引用类 (MyClass[] arr = new MyClass[10];)",
      D: "反射调用 (Class.forName(\"...\"))",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["Java"],
    explanation: "C对：通过数组定义引用类时，JVM会创建数组类（如[LMyClass;），但不会触发其元素类（MyClass）的初始化。A/B/D错：这些都会触发类的加载（如果尚未加载）和初始化。",
  },
  {
    content: "在 Spring Bean 的生命周期中，@PostConstruct 注解的方法是在什么时候执行的？",
    type: "single",
    options: {
      A: "构造函数执行之前",
      B: "构造函数执行之后，依赖注入（Set属性）之前",
      C: "依赖注入（Set属性）之后，init-method 之前",
      D: "Bean 销毁时",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["Java"],
    explanation: "C对：Spring Bean生命周期的标准顺序为：实例化（Constructor）→ 依赖注入（Populate Properties）→ @PostConstruct → init-method（如有）→ Bean就绪。A/B/D错：不符合执行顺序。",
  },
  {
    content: "想要实现一个“每分钟限制访问 100 次”的限流功能，最适合的 Redis 数据结构或命令是？",
    type: "single",
    options: {
      A: "Set (集合)",
      B: "List (队列)",
      C: "Hash (哈希)",
      D: "zset (滑动窗口) 或 incr + expire (固定窗口)",
    },
    correctAnswer: ["D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "D对：两种主流方案：1）固定窗口：使用INCR命令对键（如user:ip:minute）自增，并设置EXPIRE为60秒，判断是否超过100。2）滑动窗口：使用ZSET，以时间戳为score，每次请求插入一个成员，移除窗口外的旧成员，统计总数是否超限。A/B/C错：不适合实现精确的时间窗口限流。",
  },
  {
    content: "TCP 三次握手中，第三次握手（客户端发送 ACK）如果丢失了，服务器会怎么处理？",
    type: "single",
    options: {
      A: "服务器直接建立连接成功",
      B: "服务器关闭连接",
      C: "服务器会重传 SYN+ACK 包",
      D: "客户端会报错",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "C对：服务器在发送SYN+ACK后进入SYN_RCVD状态，并启动定时器等待客户端的ACK。若超时未收到，服务器会重传SYN+ACK包（次数和间隔依系统配置）。A/B/D错：服务器无法单方面建立连接；不会立即关闭；客户端已进入ESTABLISHED状态，通常不会立即报错。",
  },
  {
    content: "下列哪种情况不会触发 JVM 的类加载（Class Loading）？",
    type: "single",
    options: {
      A: "new 一个对象",
      B: "访问类的静态变量（static int x = 1）",
      C: "通过数组定义引用类 (MyClass[] arr = new MyClass[10];)",
      D: "反射调用 (Class.forName(\"...\"))",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["Java"],
    explanation: "C对：通过数组定义引用类时，JVM会创建数组类（如[LMyClass;），但不会触发其元素类（MyClass）的初始化。A/B/D错：这些都会触发类的加载（如果尚未加载）和初始化。",
  },
  {
    content: "在 Spring Bean 的生命周期中，@PostConstruct 注解的方法是在什么时候执行的？",
    type: "single",
    options: {
      A: "构造函数执行之前",
      B: "构造函数执行之后，依赖注入（Set属性）之前",
      C: "依赖注入（Set属性）之后，init-method 之前",
      D: "Bean 销毁时",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["Java"],
    explanation: "C对：Spring Bean生命周期的标准顺序为：实例化（Constructor）→ 依赖注入（Populate Properties）→ @PostConstruct → init-method（如有）→ Bean就绪。A/B/D错：不符合执行顺序。",
  },
  {
    content: "想要实现一个“每分钟限制访问 100 次”的限流功能，最适合的 Redis 数据结构或命令是？",
    type: "single",
    options: {
      A: "Set (集合)",
      B: "List (队列)",
      C: "Hash (哈希)",
      D: "zset (滑动窗口) 或 incr + expire (固定窗口)",
    },
    correctAnswer: ["D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "D对：两种主流方案：1）固定窗口：使用INCR命令对键（如user:ip:minute）自增，并设置EXPIRE为60秒，判断是否超过100。2）滑动窗口：使用ZSET，以时间戳为score，每次请求插入一个成员，移除窗口外的旧成员，统计总数是否超限。A/B/C错：不适合实现精确的时间窗口限流。",
  },
  {
    content: "TCP 三次握手中，第三次握手（客户端发送 ACK）如果丢失了，服务器会怎么处理？",
    type: "single",
    options: {
      A: "服务器直接建立连接成功",
      B: "服务器关闭连接",
      C: "服务器会重传 SYN+ACK 包",
      D: "客户端会报错",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "C对：服务器在发送SYN+ACK后进入SYN_RCVD状态，并启动定时器等待客户端的ACK。若超时未收到，服务器会重传SYN+ACK包（次数和间隔依系统配置）。A/B/D错：服务器无法单方面建立连接；不会立即关闭；客户端已进入ESTABLISHED状态，通常不会立即报错。",
  },
  {
    content: "测试秒杀活动时，发现大量请求直接打垮了数据库，但 Redis 缓存层似乎没起作用。这种情况（缓存穿透/击穿/雪崩）的可能原因有哪些？",
    type: "multiple",
    options: {
      A: "缓存雪崩：大量缓存 Key 在同一时间过期，导致请求全部涌向数据库。",
      B: "缓存穿透：黑客恶意请求大量数据库中不存在的 ID（如 id=-1），导致缓存不命中，直接查库。",
      C: "Redis 宕机：缓存服务挂了，没有配置高可用集群。",
      D: "数据一致性：数据库更新了，但缓存还没更新。",
    },
    correctAnswer: ["A","B","C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend","backend","fullstack"],
    applicableLanguages: null,
    explanation: "A/B/C 对：这三者都会导致流量绕过缓存直接冲击数据库，造成数据库崩溃。D 错：数据不一致通常导致用户看到旧数据，而不是导致数据库崩溃（除非是为了保证强一致性加了重锁）。考察点：对高并发架构下缓存失效场景的理解。",
  },

  // 困难题（4题）
  {
    content: "使用 Redis (setnx + expire) 实现分布式锁时，可能遇到的坑有哪些？",
    type: "multiple",
    options: {
      A: "原子性问题： 如果 setnx 成功但 expire 失败（服务宕机），会导致死锁。",
      B: "锁误删问题： 业务执行时间超过锁过期时间，锁自动释放，被其他线程抢占，当前线程执行完后删除了别人的锁。",
      C: "锁续期问题： 业务逻辑执行时间过长，如何保证锁不提前过期（需要 WatchDog 机制）。",
      D: "Redis 读写分离延迟： 主从切换可能导致锁丢失。",
    },
    correctAnswer: ["A","B","C","D"],
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "均为分布式锁在Redis实现中的核心痛点。A：命令非原子性，需使用SET key value NX EX seconds命令保证原子性。B：需为锁设置唯一标识（如UUID），删除时校验标识。C：需后台线程定期续期（如Redisson的WatchDog）。D：主从异步复制下，主节点宕机可能导致锁数据丢失，需使用RedLock等算法。",
  },
  {
    content: "系统发生 “OOM: Metaspace” (元空间溢出)，可能的原因有哪些？",
    type: "multiple",
    options: {
      A: "程序中加载了大量的 Jar 包或第三方库。",
      B: "创建了大量的大对象（如 new byte[100MB]）。",
      C: "使用了大量的动态代理（CGLib/ASM），动态生成了大量 Class 类。",
      D: "线程池开得太大。",
    },
    correctAnswer: ["A","C"],
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["Java"],
    explanation: "A/C对：Metaspace（元空间）用于存储类的元数据（Klass信息）。加载大量Jar包或动态生成大量类（如Spring AOP大量使用CGLib）都会导致其耗尽。B错：大对象分配在Java堆（Heap），会导致java.lang.OutOfMemoryError: Java heap space。D错：线程过多可能导致java.lang.OutOfMemoryError: unable to create native thread。",
  },
  {
    content: "使用 Redis (setnx + expire) 实现分布式锁时，可能遇到的坑有哪些？",
    type: "multiple",
    options: {
      A: "原子性问题： 如果 setnx 成功但 expire 失败（服务宕机），会导致死锁。",
      B: "锁误删问题： 业务执行时间超过锁过期时间，锁自动释放，被其他线程抢占，当前线程执行完后删除了别人的锁。",
      C: "锁续期问题： 业务逻辑执行时间过长，如何保证锁不提前过期（需要 WatchDog 机制）。",
      D: "Redis 读写分离延迟： 主从切换可能导致锁丢失。",
    },
    correctAnswer: ["A","B","C","D"],
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "均为分布式锁在Redis实现中的核心痛点。A：命令非原子性，需使用SET key value NX EX seconds命令保证原子性。B：需为锁设置唯一标识（如UUID），删除时校验标识。C：需后台线程定期续期（如Redisson的WatchDog）。D：主从异步复制下，主节点宕机可能导致锁数据丢失，需使用RedLock等算法。",
  },
  {
    content: "系统发生 “OOM: Metaspace” (元空间溢出)，可能的原因有哪些？",
    type: "multiple",
    options: {
      A: "程序中加载了大量的 Jar 包或第三方库。",
      B: "创建了大量的大对象（如 new byte[100MB]）。",
      C: "使用了大量的动态代理（CGLib/ASM），动态生成了大量 Class 类。",
      D: "线程池开得太大。",
    },
    correctAnswer: ["A","C"],
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["Java"],
    explanation: "A/C对：Metaspace（元空间）用于存储类的元数据（Klass信息）。加载大量Jar包或动态生成大量类（如Spring AOP大量使用CGLib）都会导致其耗尽。B错：大对象分配在Java堆（Heap），会导致java.lang.OutOfMemoryError: Java heap space。D错：线程过多可能导致java.lang.OutOfMemoryError: unable to create native thread。",
  }
];
