import { SeedQuestion } from "./types";

export const architectureQuestions: SeedQuestion[] = [
  // 简单题（5题）
  {
    content: "HTTP 协议中，状态码 304 Not Modified 表示？",
    type: "single",
    options: {
      A: "资源永久移动",
      B: "服务器内部错误",
      C: "资源未修改，客户端可直接使用本地缓存",
      D: "没有权限访问",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend", "fullstack"],
    applicableLanguages: null,
    explanation: "304状态码属于HTTP协商缓存的一部分。当客户端发送包含缓存验证信息的请求后，如果服务器判断资源自上次请求以来未发生修改，就会返回304，指示客户端使用本地缓存的版本。",
  },
  {
    content: "下列哪种情况不会触发 JVM 的类加载（Class Loading）？",
    type: "single",
    options: {
      A: "new 一个对象",
      B: "访问类的静态变量（static int x = 1）",
      C: "通过数组定义引用类 (MyClass[] arr = new MyClass[10];)",
      D: "反射调用 (Class.forName(\"...\"))",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：通过数组定义引用类时，JVM会创建数组类（如[LMyClass;），但不会触发其元素类（MyClass）的初始化。A/B/D错：这些都会触发类的加载（如果尚未加载）和初始化。",
  },
  {
    content: "在 Spring Bean 的生命周期中，@PostConstruct 注解的方法是在什么时候执行的？",
    type: "single",
    options: {
      A: "构造函数执行之前",
      B: "构造函数执行之后，依赖注入（Set属性）之前",
      C: "依赖注入（Set属性）之后，init-method 之前",
      D: "Bean 销毁时",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：Spring Bean生命周期的标准顺序为：实例化（Constructor）→ 依赖注入（Populate Properties）→ @PostConstruct → init-method（如有）→ Bean就绪。A/B/D错：不符合执行顺序。",
  },
  {
    content: "想要实现一个\"每分钟限制访问 100 次\"的限流功能，最适合的 Redis 数据结构或命令是？",
    type: "single",
    options: {
      A: "Set (集合)",
      B: "List (队列)",
      C: "Hash (哈希)",
      D: "zset (滑动窗口) 或 incr + expire (固定窗口)",
    },
    correctAnswer: ["D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "D对：两种主流方案：1）固定窗口：使用INCR命令对键（如user:ip:minute）自增，并设置EXPIRE为60秒，判断是否超过100。2）滑动窗口：使用ZSET，以时间戳为score，每次请求插入一个成员，移除窗口外的旧成员，统计总数是否超限。A/B/C错：不适合实现精确的时间窗口限流。",
  },
  {
    content: "TCP 三次握手中，第三次握手（客户端发送 ACK）如果丢失了，服务器会怎么处理？",
    type: "single",
    options: {
      A: "服务器直接建立连接成功",
      B: "服务器关闭连接",
      C: "服务器会重传 SYN+ACK 包",
      D: "客户端会报错",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "C对：服务器在发送SYN+ACK后进入SYN_RCVD状态，并启动定时器等待客户端的ACK。若超时未收到，服务器会重传SYN+ACK包（次数和间隔依系统配置）。A/B/D错：服务器无法单方面建立连接；不会立即关闭；客户端已进入ESTABLISHED状态，通常不会立即报错。",
  },

  // 困难题（2题）
  {
    content: "使用 Redis (setnx + expire) 实现分布式锁时，可能遇到的坑有哪些？",
    type: "multiple",
    options: {
      A: "原子性问题： 如果 setnx 成功但 expire 失败（服务宕机），会导致死锁。",
      B: "锁误删问题： 业务执行时间超过锁过期时间，锁自动释放，被其他线程抢占，当前线程执行完后删除了别人的锁。",
      C: "锁续期问题： 业务逻辑执行时间过长，如何保证锁不提前过期（需要 WatchDog 机制）。",
      D: "Redis 读写分离延迟： 主从切换可能导致锁丢失。",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "均为分布式锁在Redis实现中的核心痛点。A：命令非原子性，需使用SET key value NX EX seconds命令保证原子性。B：需为锁设置唯一标识（如UUID），删除时校验标识。C：需后台线程定期续期（如Redisson的WatchDog）。D：主从异步复制下，主节点宕机可能导致锁数据丢失，需使用RedLock等算法。",
  },
  {
    content: "系统发生 \"OOM: Metaspace\" (元空间溢出)，可能的原因有哪些？",
    type: "multiple",
    options: {
      A: "程序中加载了大量的 Jar 包或第三方库。",
      B: "创建了大量的大对象（如 new byte[100MB]）。",
      C: "使用了大量的动态代理（CGLib/ASM），动态生成了大量 Class 类。",
      D: "线程池开得太大。",
    },
    correctAnswer: ["A", "C"],
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "A/C对：Metaspace（元空间）用于存储类的元数据（Klass信息）。加载大量Jar包或动态生成大量类（如Spring AOP大量使用CGLib）都会导致其耗尽。B错：大对象分配在Java堆（Heap），会导致java.lang.OutOfMemoryError: Java heap space。D错：线程过多可能导致java.lang.OutOfMemoryError: unable to create native thread。",
  },

  // 新增题目 - easy (6题，含1题简答)
  {
    content: "在开发一个电商系统时，你发现商品详情页访问量很大，但数据变化不频繁。以下哪种缓存策略最合适？",
    type: "single",
    options: {
      A: "不使用缓存，直接查询数据库",
      B: "使用 Redis 缓存商品信息，设置30分钟过期时间",
      C: "使用本地内存缓存，不设置过期时间",
      D: "每次请求都刷新缓存",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：Redis缓存可以减轻数据库压力，设置合理的过期时间可以保证数据更新。A错：高并发下会导致数据库压力过大。C错：本地缓存无法在集群环境下共享，且不设置过期时间可能导致数据不一致。D错：失去了缓存的意义。",
  },
  {
    content: "在设计 RESTful API 时，以下哪种设计最符合规范？",
    type: "single",
    options: {
      A: "GET /api/getUserById?id=123",
      B: "POST /api/user/123",
      C: "GET /api/users/123",
      D: "GET /api/user?id=123&action=get",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend", "frontend", "fullstack"],
    applicableLanguages: null,
    explanation: "C对：RESTful规范中，资源使用名词复数形式，使用GET方法获取资源，路径参数表示资源ID。A错：动词getUserById不符合RESTful风格。B错：POST用于创建资源，不适合获取。D错：action参数不符合RESTful设计。",
  },
  {
    content: "在微服务架构中，服务A需要调用服务B的接口。以下哪种方式最适合处理服务B不可用的情况？",
    type: "single",
    options: {
      A: "直接抛出异常，让调用方处理",
      B: "使用熔断器（Circuit Breaker）模式，快速失败并返回降级结果",
      C: "无限重试直到服务恢复",
      D: "忽略错误，返回空数据",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：熔断器模式可以在服务不可用时快速失败，避免资源浪费，同时可以返回降级数据保证用户体验。A错：会导致错误向上传播，影响整个系统。C错：无限重试会消耗资源，可能导致雪崩。D错：返回空数据可能导致业务逻辑错误。",
  },
  {
    content: "在配置 Nginx 负载均衡时，以下哪种策略可以保证同一用户的请求总是转发到同一台服务器？",
    type: "single",
    options: {
      A: "轮询（round-robin）",
      B: "IP哈希（ip_hash）",
      C: "最少连接（least_conn）",
      D: "随机（random）",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：IP哈希根据客户端IP计算哈希值，相同IP的请求会转发到同一台服务器，适合需要保持会话的场景。A/C/D错：这些策略无法保证同一用户的请求总是到同一台服务器。",
  },
  {
    content: "在 Spring Boot 项目中，你需要配置多个数据源（如主从数据库）。以下哪种方式最合适？",
    type: "single",
    options: {
      A: "使用多个 @Primary 注解",
      B: "配置多个 DataSource Bean，使用 @Qualifier 指定",
      C: "只配置一个 DataSource，在代码中切换",
      D: "使用 JdbcTemplate 直接连接",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：Spring支持配置多个DataSource，通过@Qualifier可以明确指定使用哪个数据源，这是标准的多数据源配置方式。A错：@Primary只能有一个。C错：代码中切换不够灵活且容易出错。D错：JdbcTemplate需要DataSource支持。",
  },
  {
    content: "你在开发一个电商系统，需要设计缓存策略来提升性能。请设计一个电商系统的缓存策略，说明如何解决缓存穿透、击穿、雪崩问题。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 5,
    applicableRoles: ["backend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察对缓存三大问题的理解和实际解决方案。",
    referenceAnswer: "缓存策略设计：1）热点数据缓存：商品详情、用户信息等，设置30分钟过期；2）多级缓存：本地缓存+Redis，提升访问速度。解决缓存穿透：1）对不存在的数据也缓存空值，设置较短过期时间（如5分钟）；2）使用布隆过滤器（Bloom Filter）预先判断数据是否存在。解决缓存击穿：1）使用分布式锁，只允许一个线程查询数据库并更新缓存；2）热点数据设置永不过期，通过异步更新。解决缓存雪崩：1）设置随机过期时间，避免大量key同时过期；2）使用多级缓存，本地缓存作为第二道防线；3）实现缓存预热，系统启动时加载热点数据。评分标准：提到三大问题（1分），每个问题有具体解决方案（各1分），方案实用性强（1分），考虑多级缓存或预热（1分）。",
  },

  // 新增题目 - medium (4题，含1题简答)
  {
    content: "在设计一个秒杀系统时，需要考虑哪些方面来保证系统稳定性？",
    type: "multiple",
    options: {
      A: "使用消息队列削峰，将请求异步化处理",
      B: "使用 Redis 预减库存，避免超卖",
      C: "实现限流机制，限制每秒请求数",
      D: "直接对数据库进行库存扣减，保证数据一致性",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A对：消息队列可以缓冲大量请求，避免直接冲击数据库。B对：Redis的原子操作可以保证库存扣减的准确性。C对：限流可以保护系统不被流量打垮。D错：高并发下直接操作数据库会导致数据库压力过大，应该先在Redis中处理。",
  },
  {
    content: "在微服务架构中，服务之间需要进行服务发现。以下哪些方案可以实现服务发现？",
    type: "multiple",
    options: {
      A: "使用 Nacos 作为注册中心",
      B: "使用硬编码的IP地址和端口",
      C: "使用 Consul 作为服务注册与发现工具",
      D: "使用 Eureka 作为服务注册中心",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/C/D对：这些都是常见的服务注册与发现工具，可以动态管理服务实例。B错：硬编码无法适应服务实例的动态变化，不符合微服务架构的要求。",
  },
  {
    content: "在处理分布式事务时，以下哪些方案可以保证数据一致性？",
    type: "multiple",
    options: {
      A: "使用两阶段提交（2PC）协议",
      B: "使用最终一致性方案，如消息队列+补偿机制",
      C: "使用 Seata 等分布式事务框架",
      D: "不使用事务，直接操作数据库",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A对：2PC是经典的分布式事务协议，但性能较差。B对：最终一致性适合对一致性要求不高的场景，通过消息队列和补偿机制实现。C对：Seata提供了AT、TCC等多种模式。D错：无法保证数据一致性。",
  },
  {
    content: "你在设计一个秒杀系统，需要保证在高并发场景下的系统稳定性。请设计一个秒杀系统的限流方案，说明如何保证系统稳定性。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 5,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "本题考察高并发系统设计中的限流和稳定性保障能力。",
    referenceAnswer: "限流方案设计：1）多级限流：网关层限流（如Nginx limit_req模块）+应用层限流（如Guava RateLimiter）+接口级限流；2）限流算法：使用令牌桶或漏桶算法，允许突发流量但控制平均速率；3）限流策略：根据用户ID、IP地址进行限流，防止单用户刷接口；4）动态限流：根据系统负载动态调整限流阈值。稳定性保障：1）服务降级：限流触发时返回友好提示，而非直接拒绝；2）熔断机制：当服务异常率超过阈值时自动熔断，快速失败；3）异步处理：使用消息队列将秒杀请求异步化，削峰填谷；4）缓存预热：提前将秒杀商品信息加载到Redis，减少数据库压力；5）监控告警：实时监控QPS、响应时间、错误率等指标，及时告警。评分标准：提到多级限流或限流算法（2分），说明降级和熔断机制（1分），提到异步处理或削峰（1分），考虑监控和告警（1分）。",
  },

  // 新增题目 - hard (2题，含1题简答)
  {
    content: "在设计一个支持10万QPS的订单系统时，需要考虑哪些架构设计要点？",
    type: "multiple",
    options: {
      A: "使用读写分离，主库写，从库读",
      B: "使用分库分表，按订单ID或用户ID分片",
      C: "使用缓存层（Redis）缓存热点订单数据",
      D: "使用消息队列异步处理订单，提升响应速度",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend", "fullstack"],
    applicableLanguages: null,
    explanation: "A对：读写分离可以分散数据库压力，提升读性能。B对：分库分表可以水平扩展，支持更大数据量。C对：缓存可以大幅减少数据库访问。D对：异步处理可以提升接口响应速度，削峰填谷。",
  },
  {
    content: "你需要设计一个支持10万QPS的订单系统架构，请说明各组件的作用和选型理由。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "architecture",
    difficulty: "hard",
    weight: 5,
    applicableRoles: ["backend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察高并发系统架构设计能力。",
    referenceAnswer: "架构设计：1）网关层：使用Nginx或Kong作为API网关，实现负载均衡、限流、SSL终止；2）应用层：使用Spring Cloud微服务架构，服务拆分（订单服务、支付服务、库存服务等），使用线程池处理请求；3）缓存层：使用Redis集群缓存热点数据（商品信息、用户信息），使用本地缓存（Caffeine）作为二级缓存；4）数据库层：MySQL主从复制实现读写分离，按订单ID进行分库分表（如16库×16表），使用ShardingSphere管理分片；5）消息队列：使用RocketMQ或Kafka处理异步任务（订单创建、库存扣减、消息通知），削峰填谷；6）监控：使用Prometheus+Grafana监控系统指标，ELK收集日志。选型理由：Nginx性能高、配置灵活；Spring Cloud生态完善；Redis性能优秀、支持集群；MySQL成熟稳定；RocketMQ支持事务消息；分库分表解决单库性能瓶颈。评分标准：架构设计完整（2分），提到缓存、数据库、消息队列等关键组件（2分），选型理由合理（1分）。",
  },

  // 新增题目 - frontend角色 (18题：12 easy + 6 medium)
  {
    content: "在开发一个SPA（单页应用）时，你发现首次加载时间过长。以下哪种方案可以有效减少首屏加载时间？",
    type: "single",
    options: {
      A: "将所有代码打包成一个巨大的bundle.js文件",
      B: "使用代码分割（Code Splitting）和路由懒加载",
      C: "不使用任何构建工具，直接引入所有脚本",
      D: "将所有图片都内联为base64",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：代码分割和路由懒加载可以按需加载代码，减少首屏需要加载的代码量。A错：大文件会阻塞首屏渲染。C错：没有构建优化，性能更差。D错：base64会增加HTML体积，影响首屏加载。",
  },
  {
    content: "在设计前端项目的API调用架构时，以下哪种方式最适合处理多个API请求的并发和错误处理？",
    type: "single",
    options: {
      A: "使用Promise.all()并发请求，统一处理错误",
      B: "串行调用每个API，避免并发问题",
      C: "不使用错误处理，让错误自然抛出",
      D: "每个API单独处理，不考虑统一管理",
    },
    correctAnswer: ["A"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A对：Promise.all()可以并发执行多个请求，提升性能，同时可以统一处理错误。B错：串行执行会降低性能。C/D错：缺少错误处理会导致用户体验差。",
  },
  {
    content: "在开发一个需要支持多语言的Web应用时，以下哪种国际化方案最合适？",
    type: "single",
    options: {
      A: "为每种语言创建独立的HTML文件",
      B: "使用i18n库（如react-i18next、vue-i18n）管理翻译文本",
      C: "将所有文本硬编码在代码中",
      D: "使用浏览器自动翻译功能",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：i18n库是标准的国际化解决方案，支持动态切换语言、按需加载翻译文件。A错：维护成本高，代码重复。C错：无法支持多语言。D错：自动翻译质量差，不可控。",
  },
  {
    content: "在构建一个大型前端项目时，以下哪些架构设计原则是重要的？",
    type: "multiple",
    options: {
      A: "组件化设计，将功能拆分为可复用的组件",
      B: "状态管理集中化，使用Redux/Vuex等状态管理库",
      C: "所有代码都写在一个文件中，方便查找",
      D: "使用TypeScript提供类型安全，减少运行时错误",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：组件化、状态管理、类型安全都是大型项目的重要架构原则。C错：单文件会导致代码难以维护，不符合模块化原则。",
  },
  {
    content: "在设计前端项目的构建流程时，以下哪些优化措施可以提升生产环境性能？",
    type: "multiple",
    options: {
      A: "代码压缩和混淆，减少文件体积",
      B: "Tree Shaking移除未使用的代码",
      C: "将所有依赖都打包进主bundle，避免额外请求",
      D: "使用CDN加速静态资源加载",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：代码压缩、Tree Shaking、CDN都是常见的生产环境优化手段。C错：应该按需加载，而不是全部打包，会增加首屏加载时间。",
  },
  {
    content: "在开发一个需要实时更新的数据展示页面时，以下哪种方案最适合？",
    type: "single",
    options: {
      A: "使用定时器每秒刷新整个页面",
      B: "使用WebSocket建立长连接，服务端推送数据更新",
      C: "让用户手动刷新页面获取最新数据",
      D: "使用localStorage缓存数据，永不更新",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：WebSocket可以实现服务端主动推送，实时性好，资源消耗低。A错：定时刷新会浪费资源，且可能错过更新。C错：用户体验差。D错：数据不更新，失去实时性。",
  },
  {
    content: "在开发一个需要支持离线访问的PWA应用时，以下哪些技术是必需的？",
    type: "multiple",
    options: {
      A: "Service Worker实现离线缓存",
      B: "Web App Manifest定义应用元数据",
      C: "使用localStorage存储所有数据",
      D: "IndexedDB存储结构化数据",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：Service Worker是PWA的核心，实现离线功能；Manifest定义PWA元数据；IndexedDB适合存储大量结构化数据。C错：localStorage容量有限，不适合存储大量数据。",
  },
  {
    content: "在设计前端项目的错误监控方案时，以下哪些措施是必要的？",
    type: "multiple",
    options: {
      A: "使用Sentry等错误监控工具捕获前端错误",
      B: "实现全局错误边界（Error Boundary）捕获React组件错误",
      C: "忽略所有错误，避免影响用户体验",
      D: "记录用户操作日志，便于复现问题",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：错误监控、错误边界、操作日志都是生产环境必需的。C错：忽略错误会导致问题无法发现和修复。",
  },
  {
    content: "在开发一个需要处理大量数据的表格组件时，以下哪种方案最适合提升性能？",
    type: "single",
    options: {
      A: "一次性渲染所有数据到DOM",
      B: "使用虚拟滚动（Virtual Scrolling），只渲染可见区域的数据",
      C: "使用固定高度，不处理滚动",
      D: "将所有数据存储在内存中，不进行分页",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：虚拟滚动可以大幅减少DOM节点数量，提升渲染性能。A错：大量DOM节点会导致页面卡顿。C错：无法处理大量数据。D错：内存占用过大。",
  },
  {
    content: "在开发一个需要支持多端（Web、移动端）的应用时，以下哪种架构方案最合适？",
    type: "single",
    options: {
      A: "为每个平台单独开发一套代码",
      B: "使用响应式设计，一套代码适配多端",
      C: "使用React Native或Flutter等跨平台框架",
      D: "只支持Web端，移动端使用浏览器访问",
    },
    correctAnswer: ["C"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "C对：跨平台框架可以一套代码多端运行，开发效率高。A错：维护成本高。B错：响应式设计无法充分利用原生能力。D错：移动端体验差。",
  },
  {
    content: "在开发一个需要处理文件上传的功能时，以下哪些优化措施是必要的？",
    type: "multiple",
    options: {
      A: "实现分片上传，支持大文件上传",
      B: "显示上传进度，提升用户体验",
      C: "不限制文件大小，让用户自由上传",
      D: "实现断点续传，支持上传失败后继续",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：分片上传、进度显示、断点续传都是文件上传的常见优化。C错：不限制文件大小可能导致服务器压力过大。",
  },
  {
    content: "在开发一个需要支持主题切换的应用时，以下哪种方案最合适？",
    type: "single",
    options: {
      A: "为每个主题创建独立的CSS文件，动态切换link标签",
      B: "使用CSS变量（CSS Custom Properties）定义主题颜色，通过JavaScript动态修改",
      C: "使用内联样式为每个元素设置颜色",
      D: "不支持主题切换，固定使用一种主题",
    },
    correctAnswer: ["B"],
    abilityDimension: "architecture",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：CSS变量可以实现动态主题切换，性能好，维护方便。A错：切换CSS文件会有闪烁。C错：内联样式难以维护。D错：无法满足用户需求。",
  },
  {
    content: "在开发一个需要处理复杂表单的应用时，以下哪些架构设计是合理的？",
    type: "multiple",
    options: {
      A: "使用表单库（如Formik、React Hook Form）管理表单状态",
      B: "实现表单验证，包括前端验证和后端验证",
      C: "所有表单字段都使用受控组件",
      D: "实现表单数据的自动保存功能",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：表单库可以简化表单管理；双重验证保证数据安全；自动保存提升用户体验。C错：不是所有字段都需要受控组件，简单字段可以使用非受控组件提升性能。",
  },
  {
    content: "在开发一个需要支持SSR（服务端渲染）的Next.js应用时，以下哪些配置是重要的？",
    type: "multiple",
    options: {
      A: "合理使用getServerSideProps和getStaticProps选择渲染策略",
      B: "使用动态导入（dynamic import）实现代码分割",
      C: "所有页面都使用SSR，不考虑性能",
      D: "配置CDN加速静态资源",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：合理选择渲染策略可以平衡SEO和性能；代码分割减少首屏加载；CDN加速提升访问速度。C错：全部SSR会导致服务器压力过大，应该根据页面特性选择。",
  },
  {
    content: "在开发一个需要处理大量图片的图片展示应用时，以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "使用图片懒加载，只加载可见区域的图片",
      B: "使用WebP格式，减少图片体积",
      C: "一次性加载所有图片，避免后续加载",
      D: "实现图片压缩，在上传时压缩图片",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：懒加载、WebP格式、图片压缩都是常见的图片优化手段。C错：一次性加载所有图片会导致首屏加载时间过长。",
  },
  {
    content: "在开发一个需要支持多租户的SaaS应用前端时，以下哪些架构设计是必要的？",
    type: "multiple",
    options: {
      A: "实现租户隔离，不同租户的数据和配置独立",
      B: "使用动态配置，根据租户加载不同的主题和功能",
      C: "所有租户共享同一套代码和配置",
      D: "实现租户级别的权限控制",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：租户隔离、动态配置、权限控制都是多租户系统的核心需求。C错：不同租户可能有不同需求，需要支持定制化。",
  },
  {
    content: "在开发一个需要处理实时协作的在线编辑器时，以下哪些技术方案是合适的？",
    type: "multiple",
    options: {
      A: "使用WebSocket实现实时数据同步",
      B: "使用操作转换（OT）或CRDT算法解决冲突",
      C: "使用定时轮询同步数据",
      D: "实现版本控制，支持撤销和重做",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：WebSocket实现实时通信；OT/CRDT解决并发冲突；版本控制支持协作。C错：轮询延迟高，不适合实时协作场景。",
  },
  {
    content: "在开发一个需要支持微前端的应用时，以下哪些架构方案是可行的？",
    type: "multiple",
    options: {
      A: "使用Module Federation实现模块共享",
      B: "使用Single-SPA等框架实现应用编排",
      C: "每个微前端应用独立部署，通过路由集成",
      D: "所有功能都写在一个应用中，不考虑拆分",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：Module Federation、Single-SPA、独立部署都是微前端的常见实现方案。D错：不符合微前端架构理念。",
  },
  {
    content: "你在开发一个大型电商前端项目，需要设计一个支持高并发的商品列表页面架构。请说明如何设计页面架构以支持大量商品数据的展示和搜索。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "architecture",
    difficulty: "medium",
    weight: 5,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "本题考察大型前端项目的架构设计能力。",
    referenceAnswer: "架构设计：1）数据层：使用虚拟滚动（Virtual Scrolling）只渲染可见商品，支持万级数据展示；使用防抖优化搜索输入，减少API请求；实现分页或无限滚动，按需加载数据。2）状态管理：使用Redux/Zustand管理商品列表状态，支持缓存和预加载；实现搜索历史记录，提升用户体验。3）性能优化：使用React.memo优化商品卡片组件，避免不必要的重渲染；图片懒加载和WebP格式，减少加载时间；使用Intersection Observer实现图片和数据的按需加载。4）搜索优化：前端实现本地搜索缓存，减少服务器压力；使用防抖限制搜索频率；支持搜索建议和自动完成。5）缓存策略：使用Service Worker缓存商品数据，支持离线访问；实现智能预加载，预测用户可能查看的商品。评分标准：提到虚拟滚动或分页（2分），说明状态管理和缓存策略（1分），考虑性能优化（1分），方案实用可落地（1分）。",
  },
];
