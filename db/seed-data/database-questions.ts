import { SeedQuestion } from "./types";

export const databaseQuestions: SeedQuestion[] = [
  // 简单题（1题）
  {
    content: "在 InnoDB 引擎的可重复读（Repeatable Read）隔离级别下，主要通过什么机制解决了大部分\"幻读\"问题？",
    type: "single",
    options: {
      A: "悲观锁",
      B: "Next-Key Lock（临键锁）和 MVCC",
      C: "读写分离",
      D: "序列化",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：InnoDB在RR级别下，通过MVCC（多版本并发控制）解决了快照读的幻读问题，通过Next-Key Lock（记录锁+间隙锁）解决了当前读的幻读问题。A/C/D错：它们并非InnoDB解决幻读的核心机制。",
  },

  // 中等题（2题）
  {
    content: "现有 Service A 调用 Service B。A 方法上有事务 @Transactional，B 方法上配置了不同的传播行为。下列场景描述正确的有？",
    type: "multiple",
    options: {
      A: "若 B 为 REQUIRED：A 报错回滚，B 也会回滚（因为是同一个事务）。",
      B: "若 B 为 REQUIRES_NEW：A 报错回滚，B 不会回滚（只要 B 执行成功）。",
      C: "若 B 为 NESTED：B 报错回滚，A 可以选择捕获异常不回滚（B 是 A 的子事务/保存点）。",
      D: "若 B 为 SUPPORTS：如果 A 没有事务，B 就会新建一个事务运行。",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "A对：REQUIRED（默认）表示加入当前事务，同属一个事务单元。B对：REQUIRES_NEW会挂起A的事务，新建一个独立事务，B的事务提交后不受A回滚影响。C对：NESTED在A的事务内创建一个保存点，B回滚到此保存点，A可捕获异常决定是否继续。D错：SUPPORTS表示如果当前存在事务则加入，否则以非事务方式运行，不会新建事务。",
  },
  {
    content: "执行 Explain 查看 SQL 执行计划时，若 Extra 列出现了以下哪些关键词，通常意味着需要优化 SQL 或索引？",
    type: "multiple",
    options: {
      A: "Using index",
      B: "Using filesort",
      C: "Using temporary",
      D: "Using index condition",
    },
    correctAnswer: ["B", "C"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B/C对：Using filesort表示无法利用索引完成排序，需要在内存或磁盘进行额外排序，效率低。Using temporary表示需要创建临时表来处理查询（如GROUP BY、ORDER BY），可能消耗大量资源。A错：Using index表示使用了覆盖索引，是高效的表现。D错：Using index condition表示使用了索引下推（ICP），是优化特性。",
  },

  // 新增题目 - easy (6题，含1题简答)
  {
    content: "在开发一个用户订单系统时，你需要查询某个用户最近一个月的订单。以下哪种查询方式性能最好？",
    type: "single",
    options: {
      A: "SELECT * FROM orders WHERE user_id = 123 AND order_date > DATE_SUB(NOW(), INTERVAL 1 MONTH)",
      B: "SELECT * FROM orders WHERE user_id = 123 ORDER BY order_date DESC LIMIT 1000",
      C: "SELECT * FROM orders WHERE user_id = 123",
      D: "SELECT * FROM orders WHERE order_date > DATE_SUB(NOW(), INTERVAL 1 MONTH) AND user_id = 123",
    },
    correctAnswer: ["A"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A对：先按user_id过滤（如果有索引），再按时间过滤，可以充分利用索引。B错：ORDER BY需要排序，性能较差。C错：查询所有订单，数据量大。D错：先按时间过滤可能扫描更多数据，应该先按user_id过滤。",
  },
  {
    content: "在设计用户表时，以下哪个字段最适合作为主键？",
    type: "single",
    options: {
      A: "用户姓名（name），因为查询时经常用到",
      B: "自增ID（id），保证唯一性和性能",
      C: "邮箱（email），因为用户登录时使用",
      D: "手机号（phone），因为用户经常输入",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：自增ID作为主键可以保证唯一性，且是整数类型，索引效率高，不会变更。A错：姓名可能重复，不适合做主键。C/D错：邮箱和手机号虽然唯一，但可能变更，且字符串类型索引效率不如整数。",
  },
  {
    content: "在 MySQL 中，以下哪种情况会导致索引失效？",
    type: "single",
    options: {
      A: "在 WHERE 条件中使用函数，如 WHERE YEAR(create_time) = 2024",
      B: "使用等值查询，如 WHERE id = 123",
      C: "使用主键查询",
      D: "使用覆盖索引查询",
    },
    correctAnswer: ["A"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A对：对索引字段使用函数会导致索引失效，因为MySQL无法利用索引的有序性。应该改为 WHERE create_time >= '2024-01-01' AND create_time < '2025-01-01'。B/C/D错：这些都是正常使用索引的情况。",
  },
  {
    content: "在事务处理中，以下哪种隔离级别可以避免脏读，但可能出现不可重复读？",
    type: "single",
    options: {
      A: "READ UNCOMMITTED（读未提交）",
      B: "READ COMMITTED（读已提交）",
      C: "REPEATABLE READ（可重复读）",
      D: "SERIALIZABLE（串行化）",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：READ COMMITTED可以避免脏读（只读已提交的数据），但可能出现不可重复读（同一事务中两次读取结果不一致）。A错：会出现脏读。C错：可以避免不可重复读。D错：最高隔离级别，性能最差。",
  },
  {
    content: "在查询订单表时，你发现某个查询很慢。通过 EXPLAIN 分析发现使用了全表扫描。以下哪种优化方式最有效？",
    type: "single",
    options: {
      A: "增加服务器内存",
      B: "为 WHERE 条件中的字段添加索引",
      C: "删除表中的部分数据",
      D: "将表改为 MyISAM 引擎",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：为WHERE条件中的字段添加索引可以大幅提升查询性能，避免全表扫描。A错：增加内存不能解决全表扫描问题。C错：删除数据治标不治本。D错：MyISAM不支持事务，不适合订单表。",
  },
  {
    content: "你在设计一个用户订单表的数据库结构，需要支持高效的查询和统计。请设计表结构，说明字段选择和索引设计理由。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "database",
    difficulty: "easy",
    weight: 5,
    applicableRoles: ["backend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察数据库表设计和索引设计能力。",
    referenceAnswer: "表结构设计：CREATE TABLE orders (order_id BIGINT PRIMARY KEY AUTO_INCREMENT, user_id BIGINT NOT NULL, product_id BIGINT NOT NULL, amount DECIMAL(10,2) NOT NULL, order_status TINYINT NOT NULL COMMENT '0-待支付 1-已支付 2-已发货 3-已完成 4-已取消', create_time DATETIME NOT NULL, update_time DATETIME NOT NULL, INDEX idx_user_id (user_id), INDEX idx_create_time (create_time), INDEX idx_user_status (user_id, order_status), INDEX idx_status_time (order_status, create_time) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 字段选择理由：1）order_id使用自增主键，保证唯一性和性能；2）金额使用DECIMAL避免精度问题；3）状态使用TINYINT节省空间；4）时间字段用于查询和统计。索引设计理由：1）idx_user_id：支持按用户查询订单；2）idx_create_time：支持按时间范围查询；3）idx_user_status：支持查询用户特定状态的订单（覆盖索引）；4）idx_status_time：支持按状态和时间统计。评分标准：表结构合理（2分），字段类型选择正确（1分），索引设计有3个以上且理由充分（1分），考虑查询场景（1分）。",
  },

  // 新增题目 - medium (4题，含1题简答)
  {
    content: "在优化慢查询时，以下哪些方法可以有效提升查询性能？",
    type: "multiple",
    options: {
      A: "使用覆盖索引，避免回表查询",
      B: "避免在 WHERE 子句中使用函数或表达式",
      C: "使用 UNION 替代 OR 条件",
      D: "为所有字段都添加索引",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A对：覆盖索引可以避免回表，减少IO操作。B对：函数会导致索引失效。C对：OR条件可能导致索引失效，UNION可以分别利用索引。D错：索引过多会影响写入性能，且不是所有字段都需要索引。",
  },
  {
    content: "在设计分库分表方案时，需要考虑哪些因素？",
    type: "multiple",
    options: {
      A: "选择合适的分片键（如用户ID、订单ID）",
      B: "考虑数据分布均匀性，避免数据倾斜",
      C: "考虑跨分片查询的性能问题",
      D: "不需要考虑扩容问题，一次性设计好即可",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A对：分片键的选择直接影响查询性能和数据分布。B对：数据倾斜会导致某些分片压力过大。C对：跨分片查询需要聚合，性能较差，应尽量避免。D错：需要考虑未来扩容，设计时要预留扩展空间。",
  },
  {
    content: "在实现读写分离时，以下哪些场景需要注意数据一致性问题？",
    type: "multiple",
    options: {
      A: "用户下单后立即查询订单，可能读不到刚写入的数据",
      B: "更新用户信息后立即查询，可能读到旧数据",
      C: "所有查询都走从库，不会有问题",
      D: "主从复制延迟导致的短暂数据不一致",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/D对：主从复制存在延迟，写后立即读可能读不到最新数据，需要采用强制读主库或延迟读取等方案。C错：主从延迟会导致数据不一致，需要特殊处理。",
  },
  {
    content: "你在生产环境中发现一条SQL查询执行很慢，通过EXPLAIN分析发现没有使用索引。请分析这条慢查询SQL，说明优化思路和具体方案。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "database",
    difficulty: "medium",
    weight: 5,
    applicableRoles: ["backend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察SQL优化和问题分析能力。",
    referenceAnswer: "分析步骤：1）使用EXPLAIN分析执行计划，查看type字段（ALL表示全表扫描）、key字段（NULL表示未使用索引）、rows字段（扫描行数）；2）检查WHERE条件是否使用了函数、表达式或类型转换；3）检查索引是否存在且字段顺序是否匹配查询条件；4）检查数据分布，区分度低的字段不适合建索引。优化方案：1）添加索引：为WHERE条件中的字段添加单列索引或联合索引，注意最左前缀原则；2）优化查询条件：避免使用函数（如YEAR(create_time)改为范围查询），避免类型转换；3）使用覆盖索引：SELECT的字段都在索引中，避免回表；4）优化JOIN：确保JOIN字段有索引，小表驱动大表；5）分页优化：使用延迟关联或子查询优化深分页；6）考虑分库分表：数据量过大时考虑水平拆分。示例：原SQL SELECT * FROM orders WHERE user_id = 123 AND DATE(create_time) = '2024-01-01'，优化为 SELECT * FROM orders WHERE user_id = 123 AND create_time >= '2024-01-01' AND create_time < '2024-01-02'，并添加索引 idx_user_time(user_id, create_time)。评分标准：分析思路清晰（2分），提出3个以上优化方案（2分），有具体示例（1分）。",
  },

  // 新增题目 - hard (2题，含1题简答)
  {
    content: "在设计一个支持千万级数据的用户表分库分表方案时，需要考虑哪些关键点？",
    type: "multiple",
    options: {
      A: "选择合适的分片键，如用户ID，保证数据分布均匀",
      B: "设计分片路由规则，如 user_id % 16 决定数据落在哪个分片",
      C: "考虑跨分片查询的性能问题，如按时间范围查询所有用户",
      D: "预留扩容空间，支持未来增加分片数量",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "database",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A对：分片键的选择直接影响数据分布和查询性能。B对：路由规则要简单高效，保证数据均匀分布。C对：跨分片查询需要聚合，性能较差，需要考虑替代方案。D对：扩容是分库分表必须考虑的问题，设计时要预留扩展空间。",
  },
  {
    content: "你需要设计一个支持千万级数据的用户表分库分表方案，请说明分片策略和路由规则。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "database",
    difficulty: "hard",
    weight: 5,
    applicableRoles: ["backend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察大规模数据下的分库分表设计能力。",
    referenceAnswer: "分片策略：1）水平分片：按用户ID进行分片，如16库×16表=256个分片，每个分片约40万数据；2）分片键选择：使用user_id作为分片键，保证同一用户的数据在同一分片，避免跨分片查询；3）分片算法：使用一致性哈希或取模算法，如 db_index = user_id % 16, table_index = (user_id / 16) % 16。路由规则：1）写操作：根据user_id计算分片，直接路由到对应库表；2）读操作：单用户查询直接路由，批量查询需要查询多个分片后聚合；3）跨分片查询：如按注册时间查询，需要查询所有分片后聚合，考虑使用ES等搜索引擎；4）扩容方案：采用一致性哈希，新增分片时只需迁移部分数据，或采用双写方案平滑迁移。注意事项：1）避免热点分片：如果user_id是自增的，可能导致数据倾斜，考虑使用雪花算法生成ID；2）事务问题：跨分片事务需要使用分布式事务方案（如Seata）或最终一致性；3）全局唯一ID：使用雪花算法或Redis生成，避免自增ID冲突；4）监控告警：监控各分片的QPS、数据量、慢查询等指标。评分标准：分片策略合理（2分），路由规则清晰（1分），考虑扩容和跨分片查询（1分），有实际可落地的方案（1分）。",
  },

  // 新增题目 - frontend角色 (20题：12 easy + 6 medium + 2 hard)
  {
    content: "在前端开发中，你发现某个列表页面加载很慢，后端API返回数据需要3秒。以下哪种优化方案最有效？",
    type: "single",
    options: {
      A: "在前端使用setTimeout延迟显示数据",
      B: "使用分页加载，每次只请求一页数据",
      C: "将所有数据一次性加载到前端内存",
      D: "不使用任何优化，等待后端优化",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：分页加载可以减少单次请求的数据量，提升响应速度。A错：延迟显示不能解决根本问题。C错：大量数据会导致内存占用过高。D错：前端也应该主动优化。",
  },
  {
    content: "在开发一个需要实时显示数据变化的页面时，以下哪种方案最适合？",
    type: "single",
    options: {
      A: "使用定时器每秒请求一次数据库",
      B: "使用WebSocket建立长连接，服务端推送数据变化",
      C: "让用户手动刷新页面",
      D: "不更新数据，只显示初始数据",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：WebSocket可以实现服务端主动推送，实时性好，资源消耗低。A错：定时轮询会浪费资源，且可能错过更新。C错：用户体验差。D错：数据不更新。",
  },
  {
    content: "在开发一个需要缓存用户数据的应用时，以下哪些存储方案是合适的？",
    type: "multiple",
    options: {
      A: "使用localStorage存储少量简单数据",
      B: "使用IndexedDB存储大量结构化数据",
      C: "使用sessionStorage存储会话数据",
      D: "将所有数据存储在内存中，页面刷新后丢失",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：localStorage适合简单数据；IndexedDB适合大量数据；sessionStorage适合会话数据。D错：内存数据会丢失，不适合持久化。",
  },
  {
    content: "在开发一个需要支持搜索功能的应用时，以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "使用防抖（debounce）限制搜索请求频率",
      B: "实现前端搜索缓存，减少服务器请求",
      C: "每次输入都立即发送搜索请求",
      D: "使用索引优化后端搜索性能",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：防抖减少请求；前端缓存提升体验；后端索引优化性能。C错：频繁请求会增加服务器压力。",
  },
  {
    content: "在开发一个需要处理表单数据的应用时，以下哪种数据验证方式最合理？",
    type: "single",
    options: {
      A: "只在前端验证，后端不验证",
      B: "前端和后端都进行验证，前端提升用户体验，后端保证数据安全",
      C: "只在后端验证，前端不验证",
      D: "不进行任何验证",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：双重验证是最佳实践，前端验证提升用户体验，后端验证保证数据安全。A错：前端验证可被绕过。C错：用户体验差。D错：数据不安全。",
  },
  {
    content: "在开发一个需要处理用户权限的应用时，以下哪种方案最合适？",
    type: "single",
    options: {
      A: "将所有权限数据存储在前端代码中",
      B: "从后端API获取权限数据，前端根据权限控制功能显示",
      C: "不进行权限控制，所有用户看到相同内容",
      D: "使用硬编码的方式判断权限",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：从后端获取权限数据，前端根据权限控制，既安全又灵活。A错：前端权限可被绕过，不安全。C错：不符合业务需求。D错：不够灵活。",
  },
  {
    content: "在开发一个需要处理数据同步的应用时，以下哪些场景需要考虑数据一致性？",
    type: "multiple",
    options: {
      A: "多个标签页同时操作同一数据",
      B: "离线编辑后上线同步数据",
      C: "实时协作编辑同一文档",
      D: "只读数据展示，不涉及修改",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/C对：这些场景都可能出现数据冲突，需要考虑一致性。D错：只读数据不存在一致性问题。",
  },
  {
    content: "在开发一个需要处理大量图片的应用时，以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "使用图片懒加载，只加载可见区域的图片",
      B: "使用WebP格式，减少图片体积",
      C: "一次性加载所有图片，避免后续加载",
      D: "实现图片压缩，在上传时压缩图片",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：懒加载、WebP格式、图片压缩都是常见的图片优化手段。C错：一次性加载所有图片会导致首屏加载时间过长。",
  },
  {
    content: "在开发一个需要处理用户输入的应用时，以下哪些安全措施是必要的？",
    type: "multiple",
    options: {
      A: "对用户输入进行XSS防护，转义特殊字符",
      B: "对用户输入进行SQL注入防护（虽然前端无法完全防护）",
      C: "不进行任何验证，直接提交数据",
      D: "实现CSRF防护，使用token验证",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：XSS防护、SQL注入防护、CSRF防护都是必要的安全措施。C错：不验证会导致安全风险。",
  },
  {
    content: "在开发一个需要处理数据缓存的SPA应用时，以下哪种缓存策略最合适？",
    type: "single",
    options: {
      A: "不缓存任何数据，每次都重新请求",
      B: "使用内存缓存，页面刷新后重新请求",
      C: "使用localStorage缓存，设置合理的过期时间",
      D: "永久缓存所有数据，永不更新",
    },
    correctAnswer: ["C"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "C对：localStorage缓存可以提升性能，设置过期时间保证数据新鲜度。A错：性能差。B错：刷新后丢失。D错：数据可能过期。",
  },
  {
    content: "在开发一个需要处理大量数据的列表页面时，以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "使用分页或无限滚动，按需加载数据",
      B: "实现数据预加载，提前加载下一页数据",
      C: "一次性加载所有数据到前端",
      D: "使用虚拟滚动，只渲染可见区域",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：分页、预加载、虚拟滚动都是处理大量数据的有效方案。C错：大量数据会导致性能问题。",
  },
  {
    content: "在开发一个需要处理实时数据的应用时，以下哪些技术方案是合适的？",
    type: "multiple",
    options: {
      A: "使用WebSocket建立长连接，服务端推送数据",
      B: "使用Server-Sent Events (SSE)实现单向数据推送",
      C: "使用定时轮询，定期请求数据",
      D: "使用HTTP/2 Server Push推送数据",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：WebSocket、SSE、HTTP/2 Push都是实现实时数据的有效方案。C错：轮询延迟高，资源消耗大。",
  },
  {
    content: "在开发一个需要处理离线数据的PWA应用时，以下哪些技术是必需的？",
    type: "multiple",
    options: {
      A: "使用Service Worker实现离线缓存",
      B: "使用IndexedDB存储结构化数据",
      C: "使用localStorage存储所有数据",
      D: "实现数据同步机制，上线后同步离线数据",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：Service Worker实现离线；IndexedDB存储大量数据；同步机制保证数据一致性。C错：localStorage容量有限。",
  },
  {
    content: "在开发一个需要处理数据可视化的应用时，以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "使用Canvas或WebGL渲染大量数据点",
      B: "实现数据采样，减少渲染的数据量",
      C: "使用SVG渲染所有数据点",
      D: "实现数据聚合，将详细数据聚合为统计数据",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：Canvas/WebGL性能好；数据采样减少渲染量；数据聚合提升性能。C错：大量SVG节点会导致性能问题。",
  },
  {
    content: "在开发一个需要处理数据导入导出的应用时，以下哪些方案是合理的？",
    type: "multiple",
    options: {
      A: "使用Web Workers处理大量数据，避免阻塞主线程",
      B: "实现流式处理，分块处理数据",
      C: "一次性加载所有数据到内存处理",
      D: "使用WebAssembly处理复杂计算",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：Web Workers避免阻塞；流式处理减少内存占用；WebAssembly提升性能。C错：大量数据会导致内存溢出。",
  },
  {
    content: "在开发一个需要处理数据搜索的应用时，以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "实现前端搜索索引，支持本地快速搜索",
      B: "使用防抖限制搜索请求频率",
      C: "每次输入都立即发送搜索请求",
      D: "实现搜索建议和自动完成功能",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A/B/D对：前端索引提升速度；防抖减少请求；搜索建议提升体验。C错：频繁请求会增加服务器压力。",
  },
  {
    content: "你在开发一个需要处理大量实时数据的监控大屏应用，数据需要每秒更新。请设计一个前端数据管理方案，说明如何高效处理和展示这些数据。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "database",
    difficulty: "hard",
    weight: 5,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "本题考察前端处理大量实时数据的能力。",
    referenceAnswer: "数据获取方案：1）使用WebSocket建立长连接，服务端推送数据更新，避免频繁轮询；2）实现数据压缩，减少传输量；3）使用二进制协议（如MessagePack）替代JSON，提升传输效率。数据处理方案：1）使用Web Workers处理数据计算，避免阻塞主线程；2）实现数据采样，对于历史数据只显示关键点；3）使用数据聚合，将详细数据聚合为统计数据；4）实现数据缓存，避免重复计算。数据展示方案：1）使用Canvas或WebGL渲染大量数据点，性能优于DOM；2）实现虚拟滚动，只渲染可见区域；3）使用数据可视化库（如ECharts、D3.js）优化渲染；4）实现增量更新，只更新变化的数据。性能优化：1）使用requestAnimationFrame优化动画；2）实现防抖和节流，限制更新频率；3）使用对象池复用对象，减少GC压力；4）监控性能指标，及时优化瓶颈。评分标准：提到WebSocket或实时通信（2分），说明数据处理和优化方案（2分），考虑性能优化（1分）。",
  },
  {
    content: "你在开发一个需要支持离线编辑的文档应用，用户可以在离线状态下编辑文档，上线后需要同步到服务器。请设计一个数据同步方案，解决冲突和数据一致性问题。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "database",
    difficulty: "hard",
    weight: 5,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "本题考察离线数据同步和冲突解决能力。",
    referenceAnswer: "离线存储方案：1）使用IndexedDB存储文档数据，支持大量数据存储；2）使用Service Worker缓存文档资源，支持离线访问；3）实现版本控制，记录每次编辑的版本号。数据同步方案：1）实现操作日志（Operation Log），记录每次编辑操作；2）使用操作转换（OT）或CRDT算法解决冲突；3）实现冲突检测，比较本地和服务器版本；4）提供冲突解决界面，让用户选择保留哪个版本。同步策略：1）上线时先拉取服务器最新版本；2）比较本地版本和服务器版本，检测冲突；3）自动合并无冲突的修改；4）对于有冲突的修改，提示用户解决。数据一致性：1）使用时间戳标记每次修改；2）实现乐观锁，防止并发修改冲突；3）实现数据校验，确保数据完整性；4）实现回滚机制，同步失败时恢复本地数据。评分标准：提到离线存储方案（1分），说明同步策略和冲突解决（2分），考虑数据一致性（1分），方案实用可落地（1分）。",
  },

  // 新增题目 - backend角色 database (5题：3 easy + 2 medium)
  {
    content: "在开发一个需要处理大量数据的查询接口时，你发现查询很慢。以下哪种优化方案最有效？",
    type: "single",
    options: {
      A: "使用SELECT *查询所有字段",
      B: "为WHERE条件中的字段添加索引",
      C: "不使用任何索引，直接全表扫描",
      D: "将所有数据加载到内存中查询",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：为WHERE条件字段添加索引可以大幅提升查询性能。A错：SELECT *会增加数据传输量。C错：全表扫描性能差。D错：大量数据会导致内存溢出。",
  },
  {
    content: "在处理一个需要保证数据一致性的业务场景时，以下哪种事务隔离级别最合适？",
    type: "single",
    options: {
      A: "READ UNCOMMITTED（读未提交）",
      B: "READ COMMITTED（读已提交）",
      C: "REPEATABLE READ（可重复读）",
      D: "SERIALIZABLE（串行化）",
    },
    correctAnswer: ["C"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "C对：REPEATABLE READ是MySQL默认隔离级别，可以避免脏读和不可重复读，性能较好。A错：会出现脏读。B错：可能出现不可重复读。D错：性能最差。",
  },
  {
    content: "在开发一个需要处理批量数据插入的接口时，以下哪种方式性能最好？",
    type: "single",
    options: {
      A: "循环执行单条INSERT语句",
      B: "使用批量INSERT，一次插入多条数据",
      C: "使用事务包裹所有INSERT语句",
      D: "不使用事务，直接插入",
    },
    correctAnswer: ["B"],
    abilityDimension: "database",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "B对：批量INSERT可以减少网络往返次数，提升性能。A错：循环插入性能差。C错：事务可以保证一致性，但批量INSERT本身性能更好。D错：需要事务保证一致性。",
  },
  {
    content: "在开发一个需要处理数据更新的接口时，以下哪些优化措施是有效的？",
    type: "multiple",
    options: {
      A: "使用批量UPDATE，一次更新多条数据",
      B: "只更新变更的字段，避免全字段更新",
      C: "使用乐观锁，通过版本号控制并发更新",
      D: "每次更新都锁定整张表",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/C对：批量更新、只更新变更字段、乐观锁都是更新操作的优化手段。D错：表锁会导致并发性能下降。",
  },
  {
    content: "在开发一个需要处理复杂查询的接口时，以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "使用JOIN替代多次查询，减少数据库往返",
      B: "使用覆盖索引，避免回表查询",
      C: "使用子查询替代JOIN",
      D: "实现查询结果缓存，减少数据库压力",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "database",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/D对：JOIN优化、覆盖索引、查询缓存都是有效的优化方案。C错：子查询不一定比JOIN性能好，需要根据具体情况选择。",
  },
];
