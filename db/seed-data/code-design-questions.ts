import { SeedQuestion } from "./types";

export const codeDesignQuestions: SeedQuestion[] = [
  // 简单题（10题）
  {
    content: "运行以下代码，控制台输出的结果是？\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}",
    type: "single",
    options: {
      A: "0 1 2",
      B: "3 3 3",
      C: "0 0 0",
      D: "1 2 3",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "由于var声明的变量i是函数作用域，循环结束后i的值变为3。setTimeout是异步宏任务，其中的箭头函数在同步代码执行完后才执行，此时它们共享同一个变量i，因此输出三个3。",
  },
  {
    content: "下列关于 z-index 不生效的原因，哪项是错误的？",
    type: "single",
    options: {
      A: "父元素设置了 overflow: hidden",
      B: "元素本身没有设置 position (或为 static)",
      C: "父元素的 z-index 比兄弟元素的 z-index 小，导致子元素无法突破父级层叠上下文",
      D: "元素的 display 设置为了 block",
    },
    correctAnswer: ["D"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "z-index属性仅对定位元素（position值不为static的元素）生效。display: block是正常的块级显示，不会影响z-index的生效。A、B、C三项都是导致z-index失效的常见原因。",
  },
  {
    content: "在 React 中，key 属性的主要作用是？",
    type: "single",
    options: {
      A: "设置 CSS 样式 ID",
      B: "在 Virtual DOM Diff 算法中唯一标识节点，提高更新性能",
      C: "绑定事件监听器",
      D: "用于全局状态管理",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "key属性帮助React识别列表中哪些元素被改变、添加或删除，从而在Diff算法中高效地复用和更新节点，是提升列表渲染性能的关键。",
  },
  {
    content: "下列代码输出顺序正确的是？\nconsole.log(1);\nnew Promise(resolve => {\n    console.log(2);\n    resolve();\n}).then(() => {\n    console.log(3);\n});\nconsole.log(4);",
    type: "single",
    options: {
      A: "1 -> 2 -> 3 -> 4",
      B: "1 -> 2 -> 4 -> 3",
      C: "1 -> 4 -> 2 -> 3",
      D: "1 -> 4 -> 3 -> 2",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "Promise构造函数是同步执行的，立即输出2。then回调属于微任务，会被推入微任务队列，等待当前同步任务（输出4）执行完毕后，再从微任务队列中取出执行，因此输出3。",
  },
  {
    content: "Vue 2.x 响应式原理的核心是基于哪个 API 实现的？",
    type: "single",
    options: {
      A: "Proxy",
      B: "Object.defineProperty",
      C: "EventTarget",
      D: "Dirty Checking (脏检查)",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "Vue 2.x 通过Object.defineProperty劫持对象属性的getter和setter，实现数据变化的追踪和视图更新。Vue 3.x 改用Proxy实现，具有更好的性能和功能。",
  },
  {
    content: "typeof null 的结果是？",
    type: "single",
    options: {
      A: "\"null\"",
      B: "\"undefined\"",
      C: "\"object\"",
      D: "\"number\"",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "typeof null 返回 \"object\" 是JavaScript语言的一个历史遗留Bug，其原理与早期JavaScript中值的二进制表示有关。这并非表示null是一个对象。",
  },
  {
    content: "关于 Java 的 HashMap 扩容机制（JDK1.8+），下列说法正确的是？",
    type: "single",
    options: {
      A: "只要元素个数超过数组长度就会扩容",
      B: "扩容时，原数组中的元素会重新计算 Hash 值并均匀打散到新数组中",
      C: "当链表长度大于 8 且数组长度大于 64 时，链表会转为红黑树",
      D: "扩容是线程安全的",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：这是JDK1.8引入的优化，防止链表过长导致查询效率下降。A错：需要超过负载因子（默认为0.75）与数组长度的乘积才会扩容。B错：JDK1.8通过高位运算确定元素在新数组中的位置，不需要重新计算Hash值。D错：HashMap非线程安全，多线程扩容可能导致死循环或数据丢失。",
  },
  {
    content: "ThreadLocal 可能会导致内存泄漏，其主要原因是？",
    type: "single",
    options: {
      A: "ThreadLocal 对象本身太大",
      B: "ThreadLocalMap 的 Key 是弱引用，但 Value 是强引用，线程不结束 Value 就不回收",
      C: "多个线程共享了同一个 ThreadLocal",
      D: "频繁进行 set 操作",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：ThreadLocalMap的Key（ThreadLocal实例）是弱引用，当ThreadLocal外部强引用消失后，Key会被GC回收，但对应的Value是强引用，若线程不结束（如线程池复用）且未调用remove()，Value将无法回收，导致内存泄漏。A/C/D错：与内存泄漏的核心原理无关。",
  },
  {
    content: "关于 #{} 和 ${} 的区别，正确的是？",
    type: "single",
    options: {
      A: "${} 是预编译，更安全",
      B: "#{} 会直接进行字符串替换，存在注入风险",
      C: "#{} 使用 PreparedStatement 预编译，可防止 SQL 注入",
      D: "两者性能没有区别",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：#{}是预编译占位符，MyBatis会将其替换为?，通过PreparedStatement设置参数，可有效防止SQL注入。A/B错：事实完全相反，${}是字符串拼接，存在注入风险。D错：#{}通常有预编译开销，但更安全，性能差异在可接受范围。",
  },
  {
    content: "Spring 源码中 JdbcTemplate 使用了哪种设计模式来处理数据库连接的打开和关闭，让用户只关注 SQL 逻辑？",
    type: "single",
    options: {
      A: "策略模式",
      B: "模板方法模式 (Template Method)",
      C: "观察者模式",
      D: "装饰器模式",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：模板方法模式定义了算法骨架（如获取连接、执行SQL、释放连接），将可变步骤（具体的SQL执行逻辑）延迟到子类或通过回调实现。JdbcTemplate的execute、query等方法正是此模式的典型应用。A/C/D错：在JdbcTemplate的核心流程中不体现这些模式。",
  },

  // 中等题（2题）
  {
    content: "关于 useEffect 的依赖数组，以下描述正确的有？",
    type: "multiple",
    options: {
      A: "如果依赖数组为空 []，回调函数只会在组件挂载（Mount）时执行一次。",
      B: "如果不传依赖数组（省略参数），回调函数会在每次组件渲染（Render）后都执行。",
      C: "如果依赖数组中的对象引用发生了变化，即使对象内容没变，也会触发回调。",
      D: "useEffect 的回调函数可以是 async 函数（如 useEffect(async () => {...})）。",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "D错：useEffect的回调函数不能直接声明为async，因为async函数返回Promise，而useEffect期望返回一个清理函数（或什么都不返回）。如需使用async/await，应在回调函数内部定义一个并立即调用。",
  },
  {
    content: "关于\"重排（Reflow）\"和\"重绘（Repaint）\"，下列说法正确的是？",
    type: "multiple",
    options: {
      A: "重排（Reflow）一定会触发重绘（Repaint）。",
      B: "重绘（Repaint）一定会触发重排（Reflow）。",
      C: "修改元素的 color、visibility 只会触发重绘。",
      D: "修改元素的 width、margin、font-size 会触发重排。",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B错：重绘是重新绘制元素的外观，不涉及几何属性的改变，因此不会触发重排。A对：重排意味着布局发生了变化，需要重新计算，之后必然要重绘。C/D对：修改颜色、可见性等不影响布局的属性，只会触发重绘；而修改尺寸、边距、字体等影响布局的属性，会触发重排。",
  },

  // 困难题（3题）
  {
    content: "在单页应用（SPA）中，以下哪些场景如果不手动清理，可能会导致内存泄漏？",
    type: "multiple",
    options: {
      A: "在 window 全局对象上挂载了大量数据。",
      B: "setInterval 定时器没有被 clearInterval。",
      C: "给 DOM 元素绑定了事件，元素被移除了，但事件监听器没解绑。",
      D: "使用了闭包（Closure）引用了大量外部变量且长期持有。",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "以上均为常见的内存泄漏场景。A：全局变量会一直存在直到页面关闭。B：定时器持有回调引用，阻止其被回收。C：被移除的DOM元素如果被事件监听器引用，则无法被GC回收。D：闭包会持有外部词法环境的引用，若闭包生命周期很长，其引用的外部变量也无法被释放。",
  },
  {
    content: "关于 Event Loop，以下代码的执行顺序描述中，哪些属于\"微任务 (Microtask)\"？",
    type: "multiple",
    options: {
      A: "Promise.then / catch / finally",
      B: "setTimeout",
      C: "process.nextTick (Node.js 环境)",
      D: "MutationObserver",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "在浏览器环境中，微任务主要包括Promise回调、MutationObserver等。Node.js环境特有process.nextTick（其优先级甚至高于Promise微任务）。B项setTimeout属于宏任务(Macrotask)。",
  },
  {
    content: "关于 Java 线程池 ThreadPoolExecutor 的执行流程，下列描述正确的有？",
    type: "multiple",
    options: {
      A: "当当前线程数 < corePoolSize 时，来新任务会直接创建新线程。",
      B: "当当前线程数 >= corePoolSize 时，新任务会优先放入 workQueue 队列。",
      C: "当队列满了，且当前线程数 < maximumPoolSize 时，会创建新线程处理任务。",
      D: "当队列满了，且线程数也达到了 maximumPoolSize，会执行拒绝策略（Reject）。",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "这四点完整描述了ThreadPoolExecutor的标准任务处理流程：1）先判断核心线程数；2）核心线程满则入队；3）队列满则判断最大线程数；4）两者皆满则触发拒绝策略。顺序符合源码逻辑。",
  },

  // 新增题目 - easy (6题，含1题简答)
  {
    content: "在 React 项目中，你发现某个列表组件在数据更新时出现闪烁，用户反馈体验不佳。以下哪种优化方案最有效？",
    type: "single",
    options: {
      A: "使用 React.memo 包裹列表项组件，避免不必要的重渲染",
      B: "将所有状态提升到全局 Redux store",
      C: "使用内联样式替代 CSS 类",
      D: "增加 setTimeout 延迟渲染",
    },
    correctAnswer: ["A"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A对：React.memo可以对组件进行浅比较，当props未变化时阻止重渲染，是优化列表性能的常见手段。B错：状态提升不一定能解决闪烁问题，反而可能增加复杂度。C错：内联样式通常性能更差。D错：延迟渲染会带来更差的用户体验。",
  },
  {
    content: "在 Vue 3 项目中，你需要在组件销毁时清理定时器。以下哪种方式是正确的？",
    type: "single",
    options: {
      A: "在 onMounted 中创建定时器，无需清理",
      B: "在 onMounted 中创建定时器，在 onBeforeUnmount 中清除",
      C: "在 setup 函数顶层创建定时器",
      D: "使用 watch 监听器自动清理",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：Vue 3 Composition API中，onMounted用于组件挂载后的初始化，onBeforeUnmount用于组件卸载前的清理，这是处理定时器、事件监听器等资源的标准模式。A/C/D错：会导致内存泄漏，定时器在组件销毁后仍会运行。",
  },
  {
    content: "在开发一个电商购物车功能时，你发现用户频繁点击\"加入购物车\"按钮会导致重复提交。以下哪种防抖/节流方案最合适？",
    type: "single",
    options: {
      A: "使用防抖（debounce），延迟300ms执行",
      B: "使用节流（throttle），限制300ms内只执行一次",
      C: "使用防抖，延迟1000ms执行",
      D: "不需要防抖或节流，直接提交即可",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B对：节流保证在指定时间间隔内至少执行一次，适合\"加入购物车\"这种需要立即响应的操作，同时防止重复提交。A错：防抖会延迟执行，用户可能感觉按钮无响应。C错：延迟过长影响用户体验。D错：会导致重复提交问题。",
  },
  {
    content: "在 Spring Boot 项目中，你需要在多个 Service 方法中记录操作日志。以下哪种方式最符合面向切面编程（AOP）的最佳实践？",
    type: "single",
    options: {
      A: "在每个方法中手动调用日志记录代码",
      B: "使用 @Aspect 注解定义切面，通过 @Around 或 @After 注解拦截方法",
      C: "在 Controller 层统一记录日志",
      D: "使用静态工具类记录日志",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：AOP是Spring框架的核心特性，通过切面可以无侵入地横切多个方法，实现日志、事务、权限等横切关注点，符合DRY原则。A错：代码重复，维护困难。C错：无法记录Service层内部调用。D错：无法自动拦截方法执行。",
  },
  {
    content: "在处理用户上传的图片时，你发现某些恶意用户上传了超大文件导致服务器内存溢出。以下哪种处理方式最合理？",
    type: "single",
    options: {
      A: "不限制文件大小，相信用户不会上传大文件",
      B: "在前端限制文件大小，后端不做校验",
      C: "前后端都限制文件大小，后端使用流式处理而非一次性加载到内存",
      D: "只限制文件数量，不限制大小",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend", "frontend", "fullstack"],
    applicableLanguages: null,
    explanation: "C对：前后端双重校验确保安全，流式处理可以避免大文件一次性加载到内存，防止OOM。A错：存在安全风险。B错：前端校验可被绕过，后端必须校验。D错：文件大小才是导致内存溢出的主要原因。",
  },
  {
    content: "你在开发一个在线编辑器功能，用户输入代码时需要实时保存。但频繁的保存请求会导致服务器压力过大。请描述一个实际项目中遇到的类似性能问题，并说明如何通过代码优化解决。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 5,
    applicableRoles: ["frontend", "backend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察实际开发场景中的性能优化能力，需要结合防抖、节流、批量提交等技术方案。",
    referenceAnswer: "实际场景：在线文档编辑器中，用户每次输入都会触发自动保存，导致1秒内可能发送数十个请求。优化方案：1）前端使用防抖（debounce）技术，用户停止输入300ms后再发送保存请求；2）使用节流（throttle）确保至少每2秒保存一次，防止长时间不保存；3）后端合并请求，将短时间内的多次保存合并为一次；4）使用WebSocket实现增量更新而非全量保存。评分标准：提到防抖/节流（2分），说明具体时间参数（1分），提到后端优化或增量更新（1分），方案实用性强（1分）。",
  },

  // 新增题目 - medium (4题，含1题简答)
  {
    content: "在 React 项目中，你发现某个页面在切换时出现白屏，通过 Performance 工具分析发现组件渲染耗时过长。以下哪些优化方案是有效的？",
    type: "multiple",
    options: {
      A: "使用 React.lazy 和 Suspense 实现路由懒加载",
      B: "使用 useMemo 缓存复杂计算结果",
      C: "将所有组件改为类组件",
      D: "使用虚拟列表（virtual list）优化长列表渲染",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "A对：路由懒加载可以减少首屏加载的代码量。B对：useMemo可以避免重复计算，提升渲染性能。D对：虚拟列表只渲染可见区域，大幅减少DOM节点数量。C错：类组件通常性能不如函数组件，且与问题无关。",
  },
  {
    content: "在 Spring Boot 项目中，你发现某个接口在高并发下响应变慢，通过日志分析发现是数据库查询导致的。以下哪些优化方案是合理的？",
    type: "multiple",
    options: {
      A: "为查询字段添加数据库索引",
      B: "使用 Redis 缓存热点数据",
      C: "将同步查询改为异步查询",
      D: "使用 @Transactional(readOnly=true) 优化只读事务",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "A对：索引可以大幅提升查询速度。B对：缓存可以减少数据库压力。D对：只读事务可以优化数据库连接和事务管理。C错：异步查询可能导致数据不一致，且不能解决根本的性能问题。",
  },
  {
    content: "在处理一个文件上传功能时，你发现大文件上传经常超时失败。以下哪些处理方式是合理的？",
    type: "multiple",
    options: {
      A: "实现分片上传（chunk upload），将大文件切分成多个小块上传",
      B: "增加服务器超时时间到1小时",
      C: "实现断点续传功能，支持上传失败后从中断处继续",
      D: "使用 WebSocket 实时传输文件内容",
    },
    correctAnswer: ["A", "C"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend", "backend", "fullstack"],
    applicableLanguages: null,
    explanation: "A对：分片上传可以避免单次请求过大导致超时，且可以并行上传提升速度。C对：断点续传提升用户体验，避免重复上传。B错：简单增加超时时间不能解决网络不稳定等问题。D错：WebSocket不适合文件上传场景，HTTP更合适。",
  },
  {
    content: "你在开发一个实时聊天功能，需要实现消息的防抖和节流。请设计一个防抖/节流函数，并说明在实际项目中的应用场景。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 5,
    applicableRoles: ["frontend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察对防抖和节流原理的理解，以及在实际项目中的应用能力。",
    referenceAnswer: "防抖函数实现：function debounce(func, delay) { let timer; return function(...args) { clearTimeout(timer); timer = setTimeout(() => func.apply(this, args), delay); }; } 节流函数实现：function throttle(func, delay) { let lastTime = 0; return function(...args) { const now = Date.now(); if (now - lastTime >= delay) { func.apply(this, args); lastTime = now; } } } 应用场景：1）防抖：搜索框输入（等待用户停止输入再搜索）、窗口resize事件；2）节流：滚动事件监听、按钮点击（防止重复提交）、实时聊天消息发送（限制发送频率）。评分标准：正确实现防抖或节流函数（2分），说明两者区别（1分），列举2个以上实际应用场景（1分），代码质量高（1分）。",
  },

  // 新增题目 - hard (2题，含1题简答)
  {
    content: "在分析一个生产环境的性能问题时，你发现某段代码存在性能瓶颈。以下哪些情况可能导致性能问题？",
    type: "multiple",
    options: {
      A: "在循环中进行数据库查询，导致N+1查询问题",
      B: "频繁创建大对象导致频繁GC，引发Stop The World",
      C: "使用同步阻塞IO处理大量并发请求",
      D: "缓存未命中率过高，大量请求穿透到数据库",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "A对：N+1查询会导致数据库压力过大，应使用批量查询或JOIN优化。B对：频繁GC会导致应用暂停，应优化对象创建和生命周期。C对：同步阻塞IO会占用线程资源，应使用异步IO或线程池。D对：缓存穿透会导致数据库压力，应使用布隆过滤器或缓存空值。",
  },
  {
    content: "你在生产环境中发现某个接口响应时间突然变长，通过分析代码和日志，发现是一段复杂的业务逻辑导致的性能瓶颈。请分析这段代码的性能问题，并提出优化方案。",
    type: "essay",
    options: null,
    correctAnswer: null,
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 5,
    applicableRoles: ["backend", "frontend", "fullstack"],
    applicableLanguages: null,
    explanation: "本题考察实际生产环境中的性能问题分析和优化能力。",
    referenceAnswer: "分析步骤：1）使用性能分析工具（如JProfiler、Chrome DevTools）定位热点代码；2）检查是否存在N+1查询、重复计算、内存泄漏等问题；3）分析算法复杂度，是否存在O(n²)等低效算法。优化方案：1）数据库层面：添加索引、优化SQL、使用批量查询替代循环查询；2）缓存层面：引入Redis缓存热点数据，减少数据库访问；3）代码层面：使用异步处理、线程池优化并发、算法优化降低复杂度；4）架构层面：考虑读写分离、分库分表、引入消息队列削峰。评分标准：分析思路清晰（2分），提出3个以上优化方案（2分），方案实用且可落地（1分）。",
  },

  // 新增题目 - backend角色 code_design (8题：6 easy + 2 medium)
  {
    content: "在开发一个需要处理大量并发请求的接口时，你发现使用synchronized关键字导致性能瓶颈。以下哪种优化方案最合适？",
    type: "single",
    options: {
      A: "使用ReentrantLock替代synchronized，提升性能",
      B: "使用ConcurrentHashMap等并发集合类",
      C: "使用线程池处理请求，避免创建过多线程",
      D: "移除所有同步机制，直接并发访问",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：线程池可以复用线程，避免频繁创建销毁线程，是处理并发请求的标准方案。A错：ReentrantLock性能不一定更好。B错：ConcurrentHashMap不能解决线程创建问题。D错：移除同步会导致线程安全问题。",
  },
  {
    content: "在处理一个需要保证数据一致性的业务场景时，以下哪种方案最合适？",
    type: "single",
    options: {
      A: "不使用事务，直接操作数据库",
      B: "使用@Transactional注解管理事务，保证ACID特性",
      C: "使用乐观锁，通过版本号控制并发",
      D: "不进行任何并发控制",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：@Transactional可以保证事务的ACID特性，是保证数据一致性的标准方案。A错：没有事务无法保证一致性。C错：乐观锁适合读多写少场景，不一定适合所有情况。D错：需要并发控制。",
  },
  {
    content: "在开发一个需要处理文件上传的接口时，以下哪些优化措施是必要的？",
    type: "multiple",
    options: {
      A: "限制文件大小，防止服务器内存溢出",
      B: "使用流式处理，避免一次性加载到内存",
      C: "不限制文件大小，让用户自由上传",
      D: "实现文件类型验证，防止恶意文件上传",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "A/B/D对：限制大小、流式处理、类型验证都是文件上传的必要安全措施。C错：不限制大小可能导致服务器压力过大。",
  },
  {
    content: "在开发一个需要处理用户认证的接口时，以下哪种方案最安全？",
    type: "single",
    options: {
      A: "将用户密码明文存储在数据库中",
      B: "使用MD5加密存储密码",
      C: "使用BCrypt等安全哈希算法加密存储密码",
      D: "不存储密码，只存储用户名",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: null,
    explanation: "C对：BCrypt等安全哈希算法是密码存储的最佳实践，包含盐值，安全性高。A错：明文存储极不安全。B错：MD5已被破解，不安全。D错：无法实现密码验证。",
  },
  {
    content: "在开发一个需要处理异常的业务方法时，以下哪种处理方式最合理？",
    type: "single",
    options: {
      A: "捕获所有异常但不处理，直接忽略",
      B: "使用try-catch捕获异常，记录日志并返回友好的错误信息",
      C: "不进行异常处理，让异常向上抛出",
      D: "使用System.out.println打印异常信息",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：捕获异常、记录日志、返回友好错误信息是异常处理的最佳实践。A错：忽略异常会导致问题无法发现。C错：需要适当处理异常。D错：生产环境应该使用日志框架。",
  },
  {
    content: "在开发一个需要处理配置信息的应用时，以下哪种方式最合适？",
    type: "single",
    options: {
      A: "将配置硬编码在代码中",
      B: "使用配置文件（如application.yml）管理配置，支持多环境",
      C: "将所有配置都写在注释中",
      D: "不进行配置管理，使用默认值",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：配置文件管理配置，支持多环境，是配置管理的最佳实践。A错：硬编码不灵活。C错：注释无法被程序读取。D错：需要配置管理。",
  },
  {
    content: "在开发一个需要处理日志记录的功能时，以下哪些实践是合理的？",
    type: "multiple",
    options: {
      A: "使用日志框架（如Logback、Log4j）记录日志",
      B: "区分日志级别（DEBUG、INFO、WARN、ERROR）",
      C: "记录敏感信息（如密码、身份证号）到日志",
      D: "实现日志轮转，避免日志文件过大",
    },
    correctAnswer: ["A", "B", "D"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "A/B/D对：日志框架、日志级别、日志轮转都是日志管理的最佳实践。C错：敏感信息不应该记录到日志中。",
  },
  {
    content: "在开发一个需要处理数据转换的业务方法时，以下哪种设计模式最合适？",
    type: "single",
    options: {
      A: "使用策略模式，支持多种转换策略",
      B: "使用工厂模式，创建不同的转换器",
      C: "使用适配器模式，适配不同的数据格式",
      D: "将所有转换逻辑写在一个方法中",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：适配器模式适合将不同格式的数据转换为统一格式。A/B对：策略模式和工厂模式也可以，但适配器模式更符合数据转换场景。D错：违反单一职责原则。",
  },
];
