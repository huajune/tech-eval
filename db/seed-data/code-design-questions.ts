import { SeedQuestion } from "./types";

export const codeDesignQuestions: SeedQuestion[] = [
  // 简单题（10题）
  {
    content: "运行以下代码，控制台输出的结果是？\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}",
    type: "single",
    options: {
      A: "0 1 2",
      B: "3 3 3",
      C: "0 0 0",
      D: "1 2 3",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "由于var声明的变量i是函数作用域，循环结束后i的值变为3。setTimeout是异步宏任务，其中的箭头函数在同步代码执行完后才执行，此时它们共享同一个变量i，因此输出三个3。",
  },
  {
    content: "下列关于 z-index 不生效的原因，哪项是错误的？",
    type: "single",
    options: {
      A: "父元素设置了 overflow: hidden",
      B: "元素本身没有设置 position (或为 static)",
      C: "父元素的 z-index 比兄弟元素的 z-index 小，导致子元素无法突破父级层叠上下文",
      D: "元素的 display 设置为了 block",
    },
    correctAnswer: ["D"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "z-index属性仅对定位元素（position值不为static的元素）生效。display: block是正常的块级显示，不会影响z-index的生效。A、B、C三项都是导致z-index失效的常见原因。",
  },
  {
    content: "在 React 中，key 属性的主要作用是？",
    type: "single",
    options: {
      A: "设置 CSS 样式 ID",
      B: "在 Virtual DOM Diff 算法中唯一标识节点，提高更新性能",
      C: "绑定事件监听器",
      D: "用于全局状态管理",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "key属性帮助React识别列表中哪些元素被改变、添加或删除，从而在Diff算法中高效地复用和更新节点，是提升列表渲染性能的关键。",
  },
  {
    content: "下列代码输出顺序正确的是？\nconsole.log(1);\nnew Promise(resolve => {\n    console.log(2);\n    resolve();\n}).then(() => {\n    console.log(3);\n});\nconsole.log(4);",
    type: "single",
    options: {
      A: "1 -> 2 -> 3 -> 4",
      B: "1 -> 2 -> 4 -> 3",
      C: "1 -> 4 -> 2 -> 3",
      D: "1 -> 4 -> 3 -> 2",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "Promise构造函数是同步执行的，立即输出2。then回调属于微任务，会被推入微任务队列，等待当前同步任务（输出4）执行完毕后，再从微任务队列中取出执行，因此输出3。",
  },
  {
    content: "Vue 2.x 响应式原理的核心是基于哪个 API 实现的？",
    type: "single",
    options: {
      A: "Proxy",
      B: "Object.defineProperty",
      C: "EventTarget",
      D: "Dirty Checking (脏检查)",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "Vue 2.x 通过Object.defineProperty劫持对象属性的getter和setter，实现数据变化的追踪和视图更新。Vue 3.x 改用Proxy实现，具有更好的性能和功能。",
  },
  {
    content: "typeof null 的结果是？",
    type: "single",
    options: {
      A: "\"null\"",
      B: "\"undefined\"",
      C: "\"object\"",
      D: "\"number\"",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "typeof null 返回 \"object\" 是JavaScript语言的一个历史遗留Bug，其原理与早期JavaScript中值的二进制表示有关。这并非表示null是一个对象。",
  },
  {
    content: "关于 Java 的 HashMap 扩容机制（JDK1.8+），下列说法正确的是？",
    type: "single",
    options: {
      A: "只要元素个数超过数组长度就会扩容",
      B: "扩容时，原数组中的元素会重新计算 Hash 值并均匀打散到新数组中",
      C: "当链表长度大于 8 且数组长度大于 64 时，链表会转为红黑树",
      D: "扩容是线程安全的",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：这是JDK1.8引入的优化，防止链表过长导致查询效率下降。A错：需要超过负载因子（默认为0.75）与数组长度的乘积才会扩容。B错：JDK1.8通过高位运算确定元素在新数组中的位置，不需要重新计算Hash值。D错：HashMap非线程安全，多线程扩容可能导致死循环或数据丢失。",
  },
  {
    content: "ThreadLocal 可能会导致内存泄漏，其主要原因是？",
    type: "single",
    options: {
      A: "ThreadLocal 对象本身太大",
      B: "ThreadLocalMap 的 Key 是弱引用，但 Value 是强引用，线程不结束 Value 就不回收",
      C: "多个线程共享了同一个 ThreadLocal",
      D: "频繁进行 set 操作",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：ThreadLocalMap的Key（ThreadLocal实例）是弱引用，当ThreadLocal外部强引用消失后，Key会被GC回收，但对应的Value是强引用，若线程不结束（如线程池复用）且未调用remove()，Value将无法回收，导致内存泄漏。A/C/D错：与内存泄漏的核心原理无关。",
  },
  {
    content: "关于 #{} 和 ${} 的区别，正确的是？",
    type: "single",
    options: {
      A: "${} 是预编译，更安全",
      B: "#{} 会直接进行字符串替换，存在注入风险",
      C: "#{} 使用 PreparedStatement 预编译，可防止 SQL 注入",
      D: "两者性能没有区别",
    },
    correctAnswer: ["C"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "C对：#{}是预编译占位符，MyBatis会将其替换为?，通过PreparedStatement设置参数，可有效防止SQL注入。A/B错：事实完全相反，${}是字符串拼接，存在注入风险。D错：#{}通常有预编译开销，但更安全，性能差异在可接受范围。",
  },
  {
    content: "Spring 源码中 JdbcTemplate 使用了哪种设计模式来处理数据库连接的打开和关闭，让用户只关注 SQL 逻辑？",
    type: "single",
    options: {
      A: "策略模式",
      B: "模板方法模式 (Template Method)",
      C: "观察者模式",
      D: "装饰器模式",
    },
    correctAnswer: ["B"],
    abilityDimension: "code_design",
    difficulty: "easy",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "B对：模板方法模式定义了算法骨架（如获取连接、执行SQL、释放连接），将可变步骤（具体的SQL执行逻辑）延迟到子类或通过回调实现。JdbcTemplate的execute、query等方法正是此模式的典型应用。A/C/D错：在JdbcTemplate的核心流程中不体现这些模式。",
  },

  // 中等题（2题）
  {
    content: "关于 useEffect 的依赖数组，以下描述正确的有？",
    type: "multiple",
    options: {
      A: "如果依赖数组为空 []，回调函数只会在组件挂载（Mount）时执行一次。",
      B: "如果不传依赖数组（省略参数），回调函数会在每次组件渲染（Render）后都执行。",
      C: "如果依赖数组中的对象引用发生了变化，即使对象内容没变，也会触发回调。",
      D: "useEffect 的回调函数可以是 async 函数（如 useEffect(async () => {...})）。",
    },
    correctAnswer: ["A", "B", "C"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "D错：useEffect的回调函数不能直接声明为async，因为async函数返回Promise，而useEffect期望返回一个清理函数（或什么都不返回）。如需使用async/await，应在回调函数内部定义一个并立即调用。",
  },
  {
    content: "关于\"重排（Reflow）\"和\"重绘（Repaint）\"，下列说法正确的是？",
    type: "multiple",
    options: {
      A: "重排（Reflow）一定会触发重绘（Repaint）。",
      B: "重绘（Repaint）一定会触发重排（Reflow）。",
      C: "修改元素的 color、visibility 只会触发重绘。",
      D: "修改元素的 width、margin、font-size 会触发重排。",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "medium",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "B错：重绘是重新绘制元素的外观，不涉及几何属性的改变，因此不会触发重排。A对：重排意味着布局发生了变化，需要重新计算，之后必然要重绘。C/D对：修改颜色、可见性等不影响布局的属性，只会触发重绘；而修改尺寸、边距、字体等影响布局的属性，会触发重排。",
  },

  // 困难题（3题）
  {
    content: "在单页应用（SPA）中，以下哪些场景如果不手动清理，可能会导致内存泄漏？",
    type: "multiple",
    options: {
      A: "在 window 全局对象上挂载了大量数据。",
      B: "setInterval 定时器没有被 clearInterval。",
      C: "给 DOM 元素绑定了事件，元素被移除了，但事件监听器没解绑。",
      D: "使用了闭包（Closure）引用了大量外部变量且长期持有。",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "以上均为常见的内存泄漏场景。A：全局变量会一直存在直到页面关闭。B：定时器持有回调引用，阻止其被回收。C：被移除的DOM元素如果被事件监听器引用，则无法被GC回收。D：闭包会持有外部词法环境的引用，若闭包生命周期很长，其引用的外部变量也无法被释放。",
  },
  {
    content: "关于 Event Loop，以下代码的执行顺序描述中，哪些属于\"微任务 (Microtask)\"？",
    type: "multiple",
    options: {
      A: "Promise.then / catch / finally",
      B: "setTimeout",
      C: "process.nextTick (Node.js 环境)",
      D: "MutationObserver",
    },
    correctAnswer: ["A", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["frontend"],
    applicableLanguages: null,
    explanation: "在浏览器环境中，微任务主要包括Promise回调、MutationObserver等。Node.js环境特有process.nextTick（其优先级甚至高于Promise微任务）。B项setTimeout属于宏任务(Macrotask)。",
  },
  {
    content: "关于 Java 线程池 ThreadPoolExecutor 的执行流程，下列描述正确的有？",
    type: "multiple",
    options: {
      A: "当当前线程数 < corePoolSize 时，来新任务会直接创建新线程。",
      B: "当当前线程数 >= corePoolSize 时，新任务会优先放入 workQueue 队列。",
      C: "当队列满了，且当前线程数 < maximumPoolSize 时，会创建新线程处理任务。",
      D: "当队列满了，且线程数也达到了 maximumPoolSize，会执行拒绝策略（Reject）。",
    },
    correctAnswer: ["A", "B", "C", "D"],
    abilityDimension: "code_design",
    difficulty: "hard",
    weight: 1,
    applicableRoles: ["backend"],
    applicableLanguages: ["java"],
    explanation: "这四点完整描述了ThreadPoolExecutor的标准任务处理流程：1）先判断核心线程数；2）核心线程满则入队；3）队列满则判断最大线程数；4）两者皆满则触发拒绝策略。顺序符合源码逻辑。",
  },
];
